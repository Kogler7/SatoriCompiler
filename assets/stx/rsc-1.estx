/**
* Extended Syntax Definition for the Reduced Language for Satori Compiler
* (c) 2023 Satori Compiler Project, Beijing Jiaotong University
*/

#meta GRAMMAR ${ $}
#meta MAPPING ${ $}
#meta SEMANTIC :

GRAMMAR ${
    Program*    ::=     { VarDeclStmt | FuncDeclStmt | FuncDef }    : SemProgram
                    ;
    VarDeclStmt ::=     VarDecl `;`                                 : SemVarDeclStmt
                    ;
    VarDecl     ::=     `var` VarDef { `,` VarDef }                : SemVarDecl
                    ;
    VarType     ::=     `int` | `real` | `bool` | `str`          : SemVarType
                    ;
    VarDef      ::=     $Ident `:` VarType { `[` $Integer `]` } [ `=` InitVal ] : SemVarDef
                    ;
    InitVal     ::=     Expr | `{` [ InitVal { `,` InitVal } ] `}` : SemInitVal
                    ;
    FuncDeclStmt::=     `decl` FuncDecl `;`                        : SemFuncDeclStmt
                    ;
    FuncDecl    ::=     `func` $Ident `(` [ ParamList ] `)` [ `:` VarType ] : SemFuncDecl
                    ;
    FuncDef     ::=     FuncDecl Block                            : SemFuncDef
                    ;
    FuncCall    ::=     $Ident `(` [ ArgList ] `)`                : SemFuncCall
                    ;
    ArgList     ::=     Expr { `,` Expr }                         : SemArgList
                    ;
    ParamList   ::=     Param { `,` Param }                      : SemParamList
                    ;
    Param       ::=     $Ident `:` VarType { `[` $Integer `]` } : SemParam
                    ;
    Stmt        ::=     Assignment `;`                           : SemAssignmentStmt
                    |   VarDeclStmt                            : SemVarDeclStmt
                    |   `if` `(` BoolExpr `)` Stmt           : SemIfStmt
                    |   `while` `(` BoolExpr `)` Stmt     : SemWhileStmt
                    |   `for` `(` ( VarDecl | Expr ) `;` BoolExpr `;` Assignment `)` Stmt : SemForStmt
                    |   `break` `;`                            : SemBreakStmt
                    |   `continue` `;`                       : SemContinueStmt
                    |   `print` Expr `;`                   : SemPrintStmt
                    |   `return` [ Expr ] `;`           : SemReturnStmt
                    |   [ Expr ] `;`                  : SemExprStmt
                    |   Block                                : SemBlockStmt
                    ;
    Assignment  ::=     LVal `=` Expr                         : SemAssignment
                    ;
    Block       ::=     `{` { Stmt } `}`                  : SemBlock
                    ;
    UnaryExpr   ::=     ( `+` | `-` | `!` ) UnaryExpr       : SemUnaryExpr
                    |   Factor                            : SemFactor
                    ;
    MulExpr     ::=     MulExpr ( `*` | `/` ) UnaryExpr    : SemMulExpr
                    |   UnaryExpr                      : SemUnaryExpr
                    ;
    Expr        ::=     Expr ( `+` | `-` ) MulExpr        : SemExpr
                    |   MulExpr                       : SemMulExpr
                    ;
    RelExpr     ::=     RelExpr ( `<` | `<=` | `>` | `>=` ) Expr    : SemRelExpr
                    |   Expr                                : SemExpr
                    ;
    EqExpr      ::=     EqExpr ( `==` | `!=` ) RelExpr  : SemEqExpr
                    |   RelExpr                        : SemRelExpr
                    ;
    AndExpr     ::=     AndExpr `&&` EqExpr           : SemAndExpr
                    |   EqExpr                     : SemEqExpr
                    ;
    OrExpr      ::=     OrExpr `||` AndExpr           : SemOrExpr
                    |   AndExpr                   : SemAndExpr
                    ;
    BoolExpr    ::=     OrExpr                   : SemBoolExpr
                    ;
    Factor      ::=     LVal                            : SemLVal
                    |   FuncCall                    : SemFuncCall
                    |   `(` Expr `)`            : SemExpr
                    |   Number                    : SemNumber
                    |   $String                   : SemString
                    |   `true`              : SemTrue
                    |   `false`           : SemFalse
                    ;
    Number      ::=     $Integer | $Real        : SemNumber
                    ;
    LVal        ::=     $Ident { `[` Expr `]` } : SemLVal
                    ;
$}

MAPPING ${
    $Ident     -->     @IDENTIFIER ;
    $Integer   -->     @INTEGER ;
    $Real      -->     @REAL ;
    $String    -->     @STRING ;
$}