#meta GRAMMAR ${ $}
#meta MAPPING ${ $}

GRAMMAR ${
    Program*        ::=     StmtList ;
    StmtList        ::=     { Stmt } ;
    KeyValExpr      ::=     Refer `=` Expr ;
    KeyValDecl      ::=     Refer [ `?` ] `:` Type [ `=` Expr ] ;
    FuncDef         ::=     FuncModifiers `func` Refer [ SuperDef ] `:` FuncTypeMark `=` StmtPack ;
    FuncTypeMark    ::=     FuncType [ `->` FuncType ] ;
    FuncType        ::=     Type | `null` | `any` ;
    ListPack        ::=     `[` [ Expr { `,` Expr } ] `]` ;
    ListUnpack      ::=     `[` [ Refer { `,` Refer } ] `]` ;
    DictPack        ::=     `{` [ KeyValExpr { `,` KeyValExpr } ] `}` ;
    DictUnpack      ::=     `{` [ Refer { `,` Refer } ] `}` ;
    TypePack        ::=     `{` [ KeyValDecl { `,` KeyValDecl } ] `}` ;
    StmtPack        ::=     `{` [ StmtList ] `}` ;
    Stmt            ::=     LetStmt | UseStmt | FuncDef | TypeDef | Expr `;` | StmtPack ;
    SuperParam      ::=     Expr | KeyValExpr ;
    SuperList       ::=     `<` SuperParam { `,` SuperParam } `>` ;
    SuperDef        ::=     `<` [ KeyValDecl { `,` KeyValDecl } ] `>` ;
    Type            ::=     PrimaryType | Refer ;
    PrimaryType     ::=     `number` | `string` | `bool` | `functor` | NumberType | StructType ;
    ScalarType      ::=     `int` | `real` | `complex` ;
    VectorType      ::=     `array` [ `[` $Int `]` ] | `matrix` { `[` $Int `]` } ;
    NumberType      ::=     ScalarType | VectorType ;
    StructType      ::=     `list` [ `[` Type `]` ] | `dict` { `[` Type `]` } ;
    FuncModifiers   ::=     { `atomic` | `async` | `global` | `inner` } ;
    FuncCall        ::=     FuncCall `.` Entity 
                            | FunctorRefer `(` Expr `)`
                            | Entity ;
    EntityChain     ::=     Entity { Entity } ;
    EntityRefer     ::=     Refer [ `[` ( $Int | Refer ) `]` ] ;
    FunctorRefer    ::=     Refer [ SuperList ] ;
    Entity          ::=     ( EntityRefer | FunctorRefer | Literal | ListPack | DictPack ) ;
    Carrier         ::=     Refer | ListUnpack | DictUnpack ;
    Expr            ::=     ( EntityChain | FuncCall ) [ ExplicitCheck ] ;
    Literal         ::=     $String | $Int | $Real | $Complex | `null` | `true` | `false` ;
    ExplicitCheck   ::=     `as` Type ;
    LetStmt         ::=     [ `let` ] Carrier [ `:` Type ] `=` Expr `;` ;
    UseStmt         ::=     `use` Carrier [ `=` ] Expr `;` ;
    TypeDef         ::=     `type` Refer `=` ( Type `;` | TypePack ) ;
    Refer           ::=     $Ident ;
$}

MAPPING ${
    $Ident     -->     @IDENTIFIER ;
    $Int       -->     @INTEGER ;
    $Real      -->     @REAL ;
    $String    -->     @STRING ;
$}