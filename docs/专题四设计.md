# 编译原理实验四

[TOC]

### 前言

### 一、目标任务

实现算符优先分析算法，完成以下描述算术表达式的算符优先文法的算符优先分析过程。

G[E]:E→E+T∣E-T∣T T→T*F∣T/F∣F F→(E)∣i 

[设计说明] 终结符号 i 为用户定义的简单变量,即标识符的定义。

[设计要求]（1）构造该算符优先文法的优先关系矩阵或优先函数；（2）输入串应是词法 分析的输出二元式序列，即某算术表达式“专题 1”的输出结果。输出为输入串是否为该文 法定义的算术表达式的判断结果。（3）算符优先分析过程应能发现输入串出错。（4）设计两 个测试用例（尽可能完备，正确和出错），并给出测试结果；（4）考虑编写程序根据算符优 先文法构造算符优先关系矩阵，并添加到你的算符优先分析程序中

### 二、设计说明

### 三、实验步骤

#### 3.1 算符优先文法的实现

##### 3.1.1 算符优先文法的继承结构

我的实验都在同一个项目中完成，因此他们彼此之间共享代码。在我的设计中，有一个文法基类，负责记录文法的终结符、非终结符、起始符号、产生式、规则等等信息，并提供了提取左公因子和消除左递归的算法，其相关定义如下：

```C++
typedef string symbol_t;
typedef set<symbol_t> symset_t;
typedef vector<symbol_t> symstr_t;
typedef pair<symbol_t, symstr_t> product_t;

class Grammar
{

public:
    symbol_t symStart;
    symset_t nonTerms;
    symset_t terminals;
    vector<product_t> products;
    map<symbol_t, set<symstr_t>> rules;
    map<token_type_t, symbol_t> tok2sym;

    Grammar(symbol_t start, symset_t terms, symset_t nonTerms, vector<product_t> products, map<symbol_t, set<symstr_t>> rules, map<token_type_t, symbol_t> tok2sym);
    Grammar() { terminals.insert(SYM_END); }
    Grammar(const Grammar &g)
    {
        symStart = g.symStart;
        terminals = g.terminals;
        nonTerms = g.nonTerms;
        tok2sym = g.tok2sym;
        products = g.products;
        rules = g.rules;
    }
    void eliminateLeftRecursion();
    void extractLeftCommonFactor();
    void printRules();
    void printTerminals();
    void printNonTerms();
    vector<token> transferTokens(vector<token> tokens);
};
```

在上面文法基类的基础之上，我通过继承实现了算符优先文法，额外提供了`FirstVT`、`LastVT`和算符优先分析表`OPT`的计算和保存。其相关定义如下：

```C++
enum OP
{
    NL = -2,
    LT = -1,
    EQ = 0,
    GT = 1
};

class OperatorPrecedenceGrammar : public Grammar
{
    symset_t calcFirstVTOf(symbol_t t);
    symset_t calcLastVTOf(symbol_t t);
    void calcFirstVT();
    void calcLastVT();
    void calcOPT();

public:
    map<symbol_t, symset_t> firstVT;
    map<symbol_t, symset_t> lastVT;
    map<symbol_t, map<symbol_t, int>> opt; // operator precedence table
    OperatorPrecedenceGrammar() : Grammar(){};
    OperatorPrecedenceGrammar(const Grammar &g) : Grammar(g)
    {
        calcFirstVT();
        calcLastVT();
        // 添加产生式S->#S#
        product_t p(symStart, {SYM_END, symStart, SYM_END});
        products.push_back(p);
        rules[symStart].insert(p.second);
        calcOPT();
    }
    OperatorPrecedenceGrammar(const OperatorPrecedenceGrammar &g) : Grammar(g)
    {
        firstVT = g.firstVT;
        lastVT = g.lastVT;
        opt = g.opt;
    }
    void printFirstVT();
    void printLastVT();
    void printOPT();
};
```



##### 3.1.2 算符优先文法的造表算法

#### 3.2 算符优先语法分析的实现



### 四、测试用例

### 五、实验总结

### 六、代码说明