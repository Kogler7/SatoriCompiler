# 编译原理实验专题六：编译器前端实现

[TOC]

## 1 写在前面

**开悟编译器第一阶段提交的报告本质上就是一整个前端的实现，下面第二章粘贴了《开悟编译器项目简要总结说明》第二章1-6节的内容（第七节是后端实现，第八节是开发工具实现，与本主题无关）。下面第三章给出了部分实验截图，用以证明程序的可用性。开悟编译器总体的项目总结会有输入输出说明，也可以参考那个。**

## 2 前端实现

### 2.1 元信息的定义和解析器实现

在我的项目中，一切**配置文件**都遵循**元信息**的格式。我定义的元信息的基础格式如下：

```
#meta PATTERN ${ $}
#meta IGNORED ${ $}

PATTERN ${
    BLANK       \s+
    LIN_CMT     //[^\r\n]*
    BLK_CMT     /\*([^\*]|\*[^/])*\*/
    IDENTIFIER  [\a_][\w]*
    SEPARATOR   [\+\-\*\\\(\)\[\]/,;=]
$}

IGNORED ${
    BLANK
    LIN_CMT
    BLK_CMT
$}
```

这是一个**词法**定义文件，文件中定义了两个元信息`#meta PATTERN`和`#meta IGNORED`，并将信息的内容通过其后定义的**起止符**包裹起来。这样的文件可以被我实现的`MetaParser`解析，从而作为后序程序的配置输入。

元信息的功用远不止于此。事实上，我为`MetaParser`添加了**递归下降**的实现方式，这使得元信息之中还可以**嵌套元信息**。同时，元信息不但支持含有起止符标记的**块信息**的解析，还支持由引导符标记的**行信息**的解析。一个典型的应用实例如下：

```
/**
* Extended Syntax Definition for the Reduced Language for Satori Compiler
* (c) 2023 Satori Compiler Project, Beijing Jiaotong University
*/

#meta GRAMMAR ${ $}
#meta MAPPING ${ $}
#meta SEMANTIC :

GRAMMAR ${
    Program*    ::=     { VarDeclStmt | FuncDeclStmt | FuncDef }   : SemProgram
                    ;
    VarDeclStmt ::=     VarDecl `;`                                : SemVarDeclStmt
                    ;
                    ......
$}
......
```

上面是从**RSC**（我计划实现的语言的名称）**文法**定义中截取的一部分，可以看到，我利用**嵌套的行信息**在EBNF中为对应的产生式添加了**语义动作**的注解。

在我的项目中，**几乎所有**需要配置的地方都接受元信息的输入，一个典型的例子如下：

```C++
/**
 * @brief Syntax Parser的构造函数，主要完成用到的词法分析器的初始化
 *
 * @param ebnfLexPath EBNF词法分析器的元数据文件路径
 */
SyntaxParser::SyntaxParser(const string ebnfLexPath)
{
    MetaParser lexMeta = MetaParser::fromFile(ebnfLexPath);
    ebnfLexer = Lexer(lexMeta["EBNF"], lexMeta["IGNORED"]);
    mappingLexer = Lexer(lexMeta["MAPPING"], lexMeta["IGNORED"]);
    precLexer = Lexer(lexMeta["PREC"], lexMeta["IGNORED"]);
}
```

元信息解析器并不是我一开始就设计实现的，而是在不断迭代完善整个编译器的过程中才出现的需求。相关的实现细节请参考源码`src/utils/meta`，在此不再赘述。

### 2.2 基于正则引擎的词法分析器

此节已在**第一次实验报告**中详细讨论过，这里只挑一些重点阐述。

#### 2.2.1 词法规则的定义

定义词法有多种方式，课上老师主要讲的是**正则文法**。我**采用的是正则表达式**，这主要是受到现代比较成熟的**词法/文法分析器生成器**的做法的启发，有其工程实践上的优势和意义。针对这样的设计，我实现了一个**正则表达式解析引擎**和**NFA构造器**，同时根据文法定义完成了词法分析结果到相应关键字、终结符的**映射**。这样做有许多好处，下面将进行讨论。

正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

一般来讲，正则表达式支持如下特性：

> 1. 字符组：用方括号 [] 来表示，可以匹配方括号中的任意一个字符。例如 [abc] 可以匹配字符 a、b 或 c。
> 2. 数量词：用来指定匹配的次数，例如 * 表示匹配 0 次或多次，+ 表示匹配 1 次或多次，? 表示匹配 0 次或 1 次，{n} 表示匹配 n 次，{n,m} 表示匹配 n 到 m 次。
> 3. 特殊字符：包括元字符、转义字符和定位符。元字符包括 .、|、() 等，用来表示特定的字符或字符集合。转义字符用来表示特殊字符，例如 \d 表示匹配数字，\s 表示匹配空白字符。定位符用来匹配字符串的位置，例如 ^ 表示匹配字符串的开头，$ 表示匹配字符串的结尾。
> 4. 分组：用圆括号 () 来表示，可以将多个字符组合成一个整体，方便进行匹配和替换。例如 (ab)+ 表示匹配一个或多个连续的 ab。
> 5. 前后查找：用来匹配某个字符前面或后面的字符。例如 (?<=a)b 表示匹配前面是 a 的 b，(?=a)b 表示匹配后面是 a 的 b。
> 6. 贪婪匹配和非贪婪匹配：默认情况下，正则表达式会尽可能地匹配更多的字符，这种匹配方式称为贪婪匹配。如果在量词后面加上 ?，则表示非贪婪匹配，即尽可能少地匹配字符。

我实现的**简易的正则表达式的解析引擎**，其所支持的功能是标准正则表达式功能的**子集**，具体功能约定如下（命名并不规范，仅作理解用）：

1. **字符组、字符区间、反选字符**：用方括号 `[]`表示字符组，匹配方括号中的**任意**一个字符。形如 `a-z`、`0-9`的字符子串表达一个字符**区间**。左方括号后紧跟一个 `^`表达对字符组所确定的字符进行**反选**，即有效字符的**全集**减去字符组内的字符得到的新字符组。
2. **转义字符、等价字符、通配符**：以转义字符 `\`开头的字符将会被转义，例如操作符 `+`被转移后就失去了操作符的含义，可用于表达对加号的匹配。特别的，`\e`等价于符号$\epsilon$，`\d`等价于 `0-9`，`\a`等价于 `a-zA-Z`，`\w`等价于 `a-zA-Z0-9_`，`\s`代表所有的空白字符，等等。`.`代表通配符，即接受有效字符的全集。
3. **单目操作符**：我实现的简易的正则表达式支持四种基本的单目操作符（均只接受**左目参数**）。`^`代表连接符（省略不写，分析程序会自动加上，无需转义）；`?`代表可选符，其之前的字符可以出现一次或零次；`+`代表正闭包，其之前的字符应至少出现一次；`*`代表闭包符，其之前的字符可以出现零次、一次或多次。
4. **双目操作符**：目前仅支持一种双目操作符 `|`，表示该操作符两边的内容是或的关系，该操作符相比上述操作符的**优先级最低**。
5. **分组**：支持使用 `()`提升圈中部分的字符的处理优先级，被圈中的字符集会被视为一个整体参与后续的计算。

正则表达式涉及到对ASCII字符串的解析，首先可以将ASCII字符大致分为两类，一类是供正则表达式引擎识别的**普通字符**，另一类则是表达正则表达式语义的**特殊字符**。其中，特殊字符主要包含**运算符**和**转义字符**。

#### 2.2.2 正则表达式的处理

我设计的正则表达式解析过程主要分为**三个阶段**。

**第一步，我的正则引擎首先会对正则表达式做预处理**。

这么做的最核心的原因是，将正则表达式转化为**整齐**的**中缀表达式**。所谓整齐，我给的定义就是指表达式中的所有**表达特定语义的单元**都必须是**单个字符**，以方便后续的解析处理。举例而言，正则表达式中范围选择语义`[0-9]`是多个字符，经过预处理后会变成一个不可见的单字符，这里用`SET`表示（预处理器会将诸如 `[0-9a-z_]`的语法先行解析，并预先存储到 `setStates`中备用）。类似的，`\e`要被处理为`EPSILON`，`\+`要被处理为`+`（因为不经转义的`+`会被识别为运算符）。

此外，为了方便后续处理，预处理器会根据字符的结合性在字符之间添加**连接符**`CONCAT`。

例如，对于正则表达式：

```reStructuredText
(\-|\+|\e)[0-9]+
```

预处理器会将其转换为：

`PARENT_L`-`SELECT`+`SELECT` `EPSILON` `PARENT_R` `CONCAT` `SET` `PLUS`

**第二步，我的正则引擎会将中缀表达式转为后缀表达式**。

这么做是因为逆波兰式更便于机器分析计算（使用**栈**即可）。

例如，对于正则表达式：

```
>=|<=|!=|==|\+\+|\-\-|\|\||&&|\*=|/=|\+=|\-=|%=|<<|>>
```

经过**预处理**得到：

.>`CONCAT`=`SELECT`<`CONCAT`=`SELECT`!`CONCAT`=`SELECT`=`CONCAT`=`SELECT`+`CONCAT`+`SELECT`-`CONCAT`-`SELECT`|`CONCAT`|`SELECT`&`CONCAT`&`SELECT`*`CONCAT`=`SELECT`/`CONCAT`=`SELECT`+`CONCAT`=`SELECT`-`CONCAT`=`SELECT`%`CONCAT`=`SELECT`<`CONCAT`<`SELECT`>`CONCAT`>

进一步转化为**后缀表达式**得到：

\>=`CONCAT`<=`CONCAT` `SELECT`!=`CONCAT` `SELECT`==`CONCAT` `SELECT`++`CONCAT` `SELECT`--`CONCAT` `SELECT`||`CONCAT` `SELECT`&&`CONCAT` `SELECT`*=`CONCAT` `SELECT`/=`CONCAT` `SELECT`+=`CONCAT` `SELECT`-=`CONCAT` `SELECT`%=`CONCAT` `SELECT`<<`CONCAT` `SELECT`>>`CONCAT` `SELECT`

**第三步，利用汤普森方法根据后缀表达式构造NFA**。

汤普森构造法是一种将正则表达式转换为NFA的方法。其基本思想是，将正则表达式中的每个字符或操作符转换为一个NFA，并通过连接和或操作符将它们组合起来。

具体步骤如下：

 1、对于正则表达式中的每个字符，构造一个只有两个状态的NFA。该NFA有一个转移边，标记为该字符。
 2、对于正则表达式中的连接（`CONCAT`）操作符，将前一个NFA的终止状态连接到后一个NFA的起始状态。
 3、对于正则表达式中的或操作符（`SELECT`），构造一个新的起始状态和一个新的终止状态，并将前一个NFA和后一个NFA分别连接到这两个状态。
 4、对于正则表达式中的闭包（`STAR`）操作符，构造一个新的起始状态和一个新的终止状态，并将原来的NFA连接到这两个状态。然后，将新的起始状态连接到原来的起始状态和新的终止状态，将原来的终止状态连接到原来的起始状态和新的终止状态。
 5、最终的NFA的起始状态为正则表达式的起始状态，终止状态为正则表达式的终止状态。

 <center>
 	<img src="https://img-blog.csdnimg.cn/img_convert/c19e51dab02f142d16b1210ce713575f.png" width="15%"></img>
 	<img src="https://img-blog.csdnimg.cn/img_convert/3bf9d5f046ce7566697d833f14fd1bd0.png" width="20%"></img>
 	<img src="https://img-blog.csdnimg.cn/img_convert/92d5f471bf9a9bfa86fc5e613848949d.png" width="20%"></img>
 	<img src="https://img-blog.csdnimg.cn/img_convert/1f371a8ed4399a9f7a69daa6ad4a0f32.png" width="25%"></img>
 </center>



类似的还可以实现`PLUS`、`QUES`等操作符，不再赘述。

通过以上步骤，我们就可以将正则表达式转换为一个NFA。

#### 2.2.3 词法分析器的简单实现

实现词法分析器有两个重要步骤。

**第一，是在上一步生成的NFA的基础上，实现针对单条规则NFA的`accepts`方法**，负责检测传入的字符串是否能被该NFA接受，并返回接受的单词内容。在我的设计实现中，该函数主要采取**递归调用**的方式，每次递归向前接受一个字符，并将接受的字符拼接到返回的结果中，若无法接受则回溯至可以接受的状态，直至找到**最长的匹配前缀**或者匹配失败。

**第二，将多条词法规则对应的NFA组合成一个词法分析器，实现`tokenize`方法**，由词法分析器决定选用哪个NFA来处理当前的字符输入流，并得到最终的词素序列。在这里，我的实现方法比较简单粗暴，核心思路就是针对当前输入流**依次（有先后顺序）**使用不同规则定义的NFA尝试匹配，并取**第一个的最长匹配结果**作为接受的`Token`。当然，针对标记为`IGNORED`类型的token，词法分析器会直接将其丢弃。

受篇幅约束，相关实现细节请查阅第一次实验报告或源码。

### 2.3 递归下降的EBNF文法解析器

在我的定义中，**文法解析器**不是**语法分析器**。语法分析器是指根据某一文法去分析输入的词素序列是否满足文法要求。这里的文法是抽象的概念。在工程实践中，需要将**文法**定义为某种**数据结构**，并将通过某种方式定义的**描述文法的文件**解析成相应的文法数据。完成这项工作的，就是本节要讨论的文法解析器。

#### 2.3.1 元信息的配置与词法解析

在 2.1 节已经指出，文法解析器接受元信息作为输入，并依次完成内部词法分析器的配置。想必您遇到的第一个疑问便是，为什么文法解析器中会有词法分析器？请参见下面关于文法解析器的类型声明：

```C++
class SyntaxParser
{
    MetaParser syntaxMeta;                // 元信息解析器
    Lexer ebnfLexer;                      // EBNF词法解析器
    Lexer mappingLexer;                   // 映射词法解析器
    Lexer precLexer;                      // 优先级词法解析器
    Grammar grammar;                      // 语法解析结果
    std::map<symbol_t, int> nonTermCount; // 非终结符计数器，用于程序自动生成唯一的新非终结符

    std::vector<tok_product_t> tokProducts; // 用于存储解析出的词素产生式
    std::vector<tok_product_t> segmentProduct(tok_product_t &product);
    void parseNonTrivialProducts(std::vector<tok_product_t> &tmp, const symbol_t &left, token_const_iter_t beginIt, token_const_iter_t endIt);

    void addSyntaxRules(const std::vector<token> &tokens);
    void addTokenMappings(const std::vector<token> &tokens);
    void addPrecAndAssoc();

public:
    SyntaxParser(const std::string syntaxLexPath);
    Grammar parse(const std::string grammarPath);
};
```

在我的项目中，文法由**EBNF**（Extended Backus-Naur Form，即扩展巴克斯-诺尔范式）定义，该范式在BNF范式的基础上，定义了几个方便的运算符，用以表达**分组、可选、重复**等语义。为了解析EBNF，我首先利用词法分析器将其转化为词素序列，以便后续分析。

针对于EBNF解析的词法分析的词法定义如下。其他类似。

```
EBNF ${
    BLANK       \s+
    EPSILON     \\e
    START_MRK   \*
    SEMANTIC    SEMANTIC
    TERMINAL    `[^`]*`
    NON_TERM    [\a_][\w']*
    MUL_TERM    $[\a_][\w']*
    TOK_TYPE    @[\a_][\w']*
    DELIMITER   [\(\){}\[\]\|]
    SEPARATOR   ;
    GRAMMAR_DEF ::=
    COMMENT     //[^\r\n]*
    COMMENT     /\*([^\*]|\*[^/])*\*/
$}
```

事实上，我的文法解析器的真正的输入是**词素序列**，包括**EBNF的词素序列、终结符映射定义的词素序列、优先级和结合性关系定义的词素序列**等等，他们分别遵循不同的词法，因此需要为文法解析器配备多个词法分析器。

关于终结符映射和优先级结合性的讨论，请参考 2.4.3 小节。

关于这部分的详细实现，请查阅源码。

#### 2.3.2 文法产生式定义的预处理

文法解析器首先会根据EBNF词素流提取出初步的产生式信息。在这个过程中得到的产生式并不是最终文法的产生式，而是包含**EBNF运算符**的**词素产生式**。

上面一段话包含两个信息。

**其一，预处理得到的词素产生式中包含EBNF运算符**。我定义的EBNF运算符有四种，分别是**`|`选择符、`()`分组符、`[]`可选符和`{}`重复符**。选择符分开的部分将分别变成单独的产生式加入到最终的文法中，分组符可以针对每个选择部分附加组外的其他部分，可选符意味着其中的部分可有可无，重复符意味着其中的部分会重复出现零次或多次。这些运算符在预处理阶段会被保留，等留到后续阶段再完成递归下降的解析处理。

下面是关于四种运算符的样例（摘自我自己设计的RSC文法）：

```ebnf
Program*    ::=     { VarDeclStmt | FuncDeclStmt | FuncDef }
VarType     ::=     `int` | `real` | `bool` | `char` | `str`
ParamList   ::=     Param { `,` Param }
UnaryExpr   ::=     ( `+` | `-` | `!` ) UnaryExpr
Stmt        ::=     `if` `(` BoolExpr `)` Stmt [ `else` Stmt ]
```

**其二，预处理得到的产生式中包含词素信息**。标准的产生式只包含终结符和非终结符，也就是源码中的`symbol`，而预处理器在这个阶段并没有将词素序列的附加信息删除。**词素中的附加信息包括，词素的类型和词素在源码中的位置**。这些信息有助于在文法解析出错时，程序可以向用户提示文法出错的上下文信息。

预处理阶段的主要工作就是根据文法定义中的分隔符`;`来完成产生式的初步拆分，详细实现请参照源码相关部分，在此不再赘述。

#### 2.3.3 递归下降的EBNF运算符解析

在我的实现中，EBNF解析器是递归下降完成解析的。这么做的根本原因是，我希望支持EBNF运算符的**嵌套**和**组合**。下面是一些典型的例子。

EBNF运算符组合：

```
VarDef ::= $Ident `:` VarType { `[` $Integer `]` } [ `=` InitVal ]
```

EBNF运算符嵌套：

```
InitVal ::= Expr | `{` [ InitVal { `,` InitVal } ] `}`
```

运算符解析的过程大致可以分为**两步**。

**第一步**，根据选择符`|`划分产生式，若发现其他运算符则对需要处理的部分**递归执行**第二步；

**第二步**，根据不同运算符执行相应处理，若发现运算符中包含选择符，则先对需要处理的部分**递归执行**第一步。

如此往复，就实现了EBNF运算符组合与嵌套的情况的解析。

从细节上来看，针对不同EBNF运算符的处理也值得讨论。

首先是针对**分组符**的处理。

文法解析器处理分组符的过程相对比较简单。它只需要将分组符所包含的内容送入上述第一步方法中，便可以得到拆分后的**子产生式向量**，而后将每一个子产生式与产生式剩余部分进行**组合**（实际上为**全连接**操作，详细原因不再赘述）即可。其处理方式可以描述如下：

```
S -> A(B|D)C => S -> ABC, S -> ADC
```

其次是针对**可选符**的处理。

可选符的处理与分组符类似，不同之处在于，文法解析器在处理可选符时需要额外构造一个**不含可选符中内容**的产生式。

```
S -> A[B|D]C => S -> ABC, S -> ADC, S -> AC
```

最后是针对**重复符**的处理。

处理重复符的过程本质上是**创建新的非终结符**，并构建**含右递归的新产生式**的过程。**程序自动构建**的新产生式将会用于**文法分析**，并在文法分析结束后通过**重构CST将其消去（将在 2.5.4 节介绍）**，最终在用户的视角来看，这一切都是**透明**的。

```
S -> A{B|D}C => S' -> B|D, S'' -> S'S'' | ε, S -> AS''C
```

#### 2.3.4 拓展语法信息的解析处理

拓展语法信息包含**终结符映射、优先级与结合性、属性文法语义动作**等信息。至于为什么需要这些信息，请参见 下面的讨论。

2.3.2 节说到，预处理阶段得到的产生式包含词素信息。经过 2.3.3 节的处理解析，各产生式基本拆分完毕。本节要做的工作，就是将词素产生式中多余的信息删去，构建出**文法实例**，同时完成拓展语法信息的解析。

解析器会首先遍历每一个词素产生式的每一个token，按照其类别将其转化为符号`symbol`，构建文法产生式，并同时生成文法的终结符、非终结符集合。这是一个**平凡**的过程，不赘述。在这个过程中，有**三个**需要注意的特别的地方。

**第一个是终结符映射信息的解析**。

在EBNF定义经过词法分析后，会产生一种名为**映射终结符**（在程序中一般命名为`mul-term`）的词素，它隐含了一种信息，即该类终结符将在语法分析阶段对应**含有多种不同的值的词素**，一种典型的映射终结符是`ident`（意为**标识符**），他将在语法分析阶段匹配多种类型为`IDENTIFIER`但值各有不同的词素。除了`ident`，还有一些常见的映射终结符，他们在项目文法中的定义如下：

```
MAPPING ${
    $Ident     -->     @IDENTIFIER ;
    $Integer   -->     @INTEGER ;
    $Real      -->     @REAL ;
    $String    -->     @STRING ;
$}
```

在上面的定义中，箭头`-->`的左边代表文法中出现的映射终结符，右边代表词法分析器解析得到的词素类型，下面分别给出文法和词法中使用映射非终结符的例子：

```
FuncDef     ::=     Type $Ident `(` [ ParamList ] `)` Block
```

```
IDENTIFIER  [\a_][\w]*
```

不难发现，映射终结符的存在是一种**必然**，因为程序代码需要支持**用户自定义符号**和**数据字面量**，而仅凭文法终结符是**无法穷举**所有可能的字符组合的，这便是映射终结符存在的意义。

上述解析大致的实现方法是，文法解析器会将带有`mul-term`类型标记的词素转化为普通的终结符，但同时填写存储在**文法数据结构**中的一个**映射表**。通过这个映射表，我们就可以在语法分析之前，先将源码遍历得到的**词素序列**做一次**映射翻译**，再将其送入语法分析器分析，这样就实现了映射。

**第二个是优先级与结合性信息的解析**。

优先级与结合性在老师讲授的文法分析的内容中并不是重点，但其在**工程实践上**意义重大。它们一方面是各类**程序语言中不可或缺的特性**，另一方面则是**解决文法二义性问题的工具**。

除了老生常谈的**表达式中优先级与结合性规则的应用**，还有一个经典的案例是`dangling else`问题。通过实践不难发现，常见的**if else**文法具有二义性。其最主要的特点是，语法分析器不知道**将else语句划分给哪一个if语句**，同时，如果文法设计的不好，该文法在SLR分析器中还会产生**移进-规约冲突**，即语法分析器在遇到`if stmt . else stmt`时不知道该移进还是该规约。这将大大限制了文法的表达能力和SLR1语法分析器的应用。

经过调研发现，现代语法分析器生成器（Yacc等）处理二义性文法的普遍做法分两步进行：

1. 按**优先级规则**消除部分移进/规约冲突

2. 再按**确定性规则**解决余下的冲突

​		a. 对于移进-规约冲突，优先移进
​		b. 对于规约-规约冲突，选用列在文法最前面的语法规则规约

当然，我们也可以选择修改文法。但这样会造成**文法规则的分散**，并为之后的**语义规则的绑定**带来额外的困难。

针对优先级的解决方案，有如下讨论

> BYacc：如果lookahead记号和栈顶符号都有优先级，选择优先级高的，如果优先级相同，则看结合性；右结合选择移进，左结合选择规约，无结合两者皆不选。如果两者不全有优先级，则优先移进（即根据确定性规则处理移进-规约冲突）
>
> CUP：如果栈顶符号有优先级，则比较它和lookahead的优先级，大于则移进，小于则规约，等于再看结合性；左结合则规约，右结合则移进，无结合则做特殊标记。如果栈顶符号没有优先级，lookahead有优先级，则移进。如果两者皆没有优先级，则用确定性规则解决。

在我的项目中，优先级和结合性通过前述元信息的方式定义，并由文法解析器解析后填入到文法数据结构中。

**第三个是属性文法语义动作的解析**。

在我的项目中，语义信息的标记如下所示：

```
GRAMMAR ${
    Program*    ::=     { VarDeclStmt | FuncDeclStmt | FuncDef }  : SemProgram
                    ;
    VarDeclStmt ::=     VarDecl `;`                               : SemVarDeclStmt
                    ;
    VarDecl     ::=     `var` VarDef { `,` VarDef }               : SemVarDecl
                    ;
$}
```

在进行文法解析的过程中，元信息解析器会将语义信息提取出来，形成一个**语义动作的序列**。文法解析器则负责在整理文法的过程中根据产生式所在的行为每个产生式附加其对应的**语义动作标记**。关于语义标记方面，我最开始采取的方案是利用**C++宏定义**来实现语义动作的自定义，但我很快发现这样做有两个巨大的缺陷。其一是宏定义会将参数中代码块中的逗号当作参数的分隔符，导致语义动作不能被正确定义；其二是通过宏定义定义的语义动作只能全局被导入一次，否则会出现重复定义的编译错误。因此，最后我丢弃了这个方案，改为采用语义动作标记加内置相关代码的方案。

### 2.4 文法和语法分析器及其扩展

#### 2.4.1 基础文法及其继承体系的设计与实现

这一节主要对标的是**实验内容**。实验要求实现LL(1)、OPG和SLR1语法分析器，我将文法和语法分析器分别抽象出来，每一种类型的分析器都接受其相应类型的文法，这样就形成了文法之间的继承体系。首先是基础文法。

> 本节所述文法相关代码均可在源码`src/common/gram`文件夹下找到。

```C++
class Grammar
{

public:
    symbol_t symStart;
    symset_t mulTerms;
    symset_t nonTerms;
    symset_t terminals;

    product_t startProduct;
    std::vector<product_t> products;
    std::map<symbol_t, std::set<symstr_t>> rules;

    std::map<token_type_t, symbol_t> tok2sym;
    std::map<product_t, semantic_t> semMap;
    std::map<symbol_t, prec_assoc_t> precMap;
    ......
};
```

为节约篇幅，上述代码隐去了一部分方法，**仅保留了类所包含的字段**，下面代码也将如此。观察上述代码不难发现，基础文法作为其他文法的基类，记录了由文法解析器解析EBNF得到的所有信息，包括**开始符号、终结符、非终结符、映射终结符、产生式、文法规则、映射关系表、语义动作表和优先级关系表**等等。

在此基础上，我们可以得到**预测文法**。所谓预测文法，可以理解为为**LL(1)语法分析器**服务的文法数据结构。其中包含了**First集、Follow集的计算方法和结果**。其实LL(1)分析法无论是利用**递归下降**分析，还是利用**显式的栈**（递归下降本质上是利用隐式的栈）进行分析，都要用到**预测分析表**，而计算First集和Follow集就是预测分析的**关键**所在。因此，该文法便得名预测文法。

预测文法的数据结构如下（这边我其实额外求了一个**select集**，会更便于判断一个文法是否是LL1文法，更便于填写预测分析表）：

```C++
class PredictiveGrammar : public Grammar
{
	......
public:
    std::map<symbol_t, symset_t> first;
    std::map<symstr_t, symset_t> firstS;
    std::map<symbol_t, symset_t> follow;
    std::map<product_t, symset_t> select;
    ......
};
```

**LR文法**继承了预测文法。在LR系列的分析法中，需要计算项目集规范族和分析表。在一些LR分析法中，需要**利用Follow集来处理冲突**，因此LR文法中需要提供计算First集和Follow集的方法，这便是LR文法需要继承自预测文法的原因。

```C++
class LRGrammar : public PredictiveGrammar
{
    ......
public:
    clusters_t clusters;
    std::vector<lr_item_t> items;
    table_t<state_id_t, symbol_t, state_id_t> goTrans;
    ......
};
```

在LR基础文法的基础上，SLR1文法又添加了SLR1分析表，其主要数据结构如下。这非常好理解，不多做解释。

```C++
class SLR1Grammar : public LRGrammar
{
    ......
public:
    table_t<state_id_t, symbol_t, action_t> slr1Table;
    ......
};
```

除了上述继承链外，算符优先文法独树一帜。它直接继承自基础文法，其数据结构如下：

```C++
class OperatorPrecedenceGrammar : public Grammar
{
    ......
public:
    std::map<symbol_t, symset_t> firstVT;
    std::map<symbol_t, symset_t> lastVT;
    table_t<symbol_t, symbol_t, int> opt; // operator precedence table
    ......
};
```

以上便是老师课上讲的几种基础的语法分析器所需要的文法信息的实现。

#### 2.4.2 经典语法分析算法的设计与实现

本节主题几乎涵盖了**课内实验内容**的**大部分重点**，这些内容在过往的**实验报告**中均有涉及和讨论，由于篇幅限制，这里不再赘述。

#### 2.4.3 扩展语法和扩展语法分析器的实现

**扩展语法**在这里并非指编译原理中**扩展文法**的概念。在**课内内容**中，扩展文法是指为已有的文法添加一个额外的包含原起始符号和新起始符号的产生式，以确保该产生式的唯一性。但在**本项目的实践**中，扩展文法主要用于记录一些传统文法所不能表达的信息，比如**属性文法、映射终结符、终结符优先级和结合性**等。

这部分信息的核心**解析工作**已经在 **2.3.4** 节讨论，本节仅论述相关信息在语法分析过程中的**应用**。能够利用扩展语法的分析器被我称为扩展语法分析器。例如，我为RSC语言写的文法就是`rsc.estx`扩展语法，而对应的语法分析器就是`ESLR`（即扩展的SLR1分析器）。

由于时间优先，我并没有完全实现对上面的信息的利用。

关于**属性文法**信息（或者说是语义动作标记），我仅仅实现了对该类信息的解析处理。后来为了更好地**优化RSC语义的分析过程**，我直接对RSC写了针对性的**Visitor**，因此最终语义动作标记没有得到使用。（但是处理语义信息的接口已经实现了，可以在此基础上实现其他简单的语义分析，就不再赘述）

关于**映射终结符**信息（相关讨论主要在 2.3.4 节），我将该信息存储在了基础文法中，而后将解析源文件得到的词素序列先经过文法的映射翻译后再送到语法分析器中分析，这样就实现了一个终结符对应多个词素值的映射。

关于**终结符优先级和结合性**信息，本来是打算用于处理SLR1分析过程中的**移进规约冲突**（对于复杂的文法这点很容易出现）和优化文法表达的。由于时间原因，我在实现了对该信息的解析之后并没有将其应用到语法分析的过程，而是直接采用了**优先移进**的原则（这点在 2.3.4 节有讨论）解决了冲突。

除了上述几个关键区别外，我解析RSC使用的扩展语法分析器还针对性地做了其他优化，由于篇幅限制，不多赘述。

### 2.5 三种解析语法树的构造转换

事实上，针对简单的文法，我们可以通过附加语义动作的产生式在语法分析的同时完成翻译。但对于复杂的文法，这样做的好处就几乎为零了。在计算机领域，尤其是涉及到编程问题的地方，有一个非常好用的**哲学**。那便是通过**添加抽象的层数**来一步步将问题**简化**，我们只需要**保证每一层和其他层之间转换的正确性**，就能**保证整个复杂的处理过程的正确性**。在这里，为了实现对RSC语言的翻译，我设计了**三种解析语法树及其互相的转换过程**。

#### 2.5.1 语法解析树PST抽象类的设计与实现

在整个项目中，有许多用得到树这一数据结构的地方。为此，我专门实现了一个抽象的树结构，支持**树节点数据的挂载、子节点的查询、子节点顺序反转、子节点访问、子节点插入、节点信息描述、子节点遍历、树的前序遍历、树的后序遍历、树的形状打印**等功能，其主要实现如下：

```C++
template <typename data_t>
class AbstractTreeNode;

template <typename data_t>
using tree_node_t = AbstractTreeNode<data_t>;

template <typename data_t>
using tree_node_ptr_t = std::shared_ptr<AbstractTreeNode<data_t>>;

template <typename data_t>
using tree_children_t = std::vector<tree_node_ptr_t<data_t>>;

template <typename data_t>
class AbstractTreeNode : public tree_children_t<data_t>
{
public:
    tree_node_t<data_t> *parent;
    data_t data;

    AbstractTreeNode(data_t data) : data(data), parent(nullptr) {}

    static tree_node_ptr_t<data_t> createNode(data_t data)
    {
        return std::make_shared<tree_node_t<data_t>>(data);
    }

    size_t find(data_t data) const
    {
        auto it = find_if(
            tree_children_t<data_t>::begin(), tree_children_t<data_t>::end(),
            [=](tree_node_ptr_t<data_t> node)
            { return node->data == data; });
        return it == tree_children_t<data_t>::end() ? -1 : it - tree_children_t<data_t>::begin();
    }

    template <typename func_t>
    size_t find(func_t cmp) const
    {
        auto it = find_if(tree_children_t<data_t>::begin(), tree_children_t<data_t>::end(), cmp);
        return it == tree_children_t<data_t>::end() ? -1 : it - tree_children_t<data_t>::begin();
    }

    void reverseChildren()
    {
        reverse(tree_children_t<data_t>::begin(), tree_children_t<data_t>::end());
    }

    tree_node_t<data_t> &operator[](size_t index) const
    {
        const auto &child = this->at(index);
        return static_cast<tree_node_t<data_t> &>(*child);
    }

    tree_node_ptr_t<data_t> get_child_ptr(size_t index) const
    {
        tree_node_ptr_t<data_t> child = this->at(index);
        return child;
    }

    tree_node_t<data_t> &operator<<(const tree_node_ptr_t<data_t> node)
    {
        node->parent = this;
        this->push_back(node);
        return static_cast<tree_node_t<data_t> &>(*this);
    }

    size_t size() const
    {
        return tree_children_t<data_t>::size();
    }

    virtual std::string descData() const
    {
        return "";
    }

    template <typename func_t>
    void foreach (func_t f) const
    {
        auto nodeF = [=](tree_children_t<data_t>::const_reference ref)
        {
            f(*ref);
        };
        for_each(tree_children_t<data_t>::begin(), tree_children_t<data_t>::end(), nodeF);
    }

    template <typename func_t>
    void traverse(func_t f) const
    {
        f(*this);
        foreach (
            [=](tree_node_t<data_t> &ref)
            { ref.traverse(f); })
            ;
    }

    template <typename func_t>
    void traverse(func_t f, int &level, int &index)
    {
        tree_node_t<data_t> &self = *this;
        f(self);
        level++;
        int tmpIdx = index++;
        index = 0;
        foreach (
            [&](tree_node_t<data_t> &ref)
            {
                ref.traverse(f, level, index);
                index++;
            })
            ;
        level--;
        index = tmpIdx;
    }

    template <typename func_t>
    void postorder(func_t f) const
    {
        foreach (
            [=](tree_node_t<data_t> &ref)
            { ref.postorder(f); })
            ;
        f(*this);
    }

    template <typename func_t>
    void postorder(func_t f, int &level, int &index)
    {
        tree_node_t<data_t> &self = *this;
        level++;
        int tmpIdx = index++;
        index = 0;
        foreach (
            [&](tree_node_t<data_t> &ref)
            {
                ref.postorder(f, level, index);
                index++;
            })
            ;
        level--;
        index = tmpIdx;
        f(self);
    }

    std::string dumpTree()
    {
        std::stringstream ss;
        std::vector<bool> visible;
        int level = 0;
        int index = 0;
        traverse(
            [&](tree_node_t<data_t> &node)
            {
                if (visible.size() <= level)
                    visible.push_back(true);
                if (level > 0)
                {
                    if (node.parent == nullptr)
                    {
                        warn << "DumpTree: Node <" << node.descData() << "> has no parent!" << std::endl;
                    }
                    else if (index == node.parent->size() - 1)
                    {
                        visible[level - 1] = false;
                    }
                }
                auto getHead = [=](int level) -> std::string
                {
                    int i = 0;
                    std::string ret;
                    while (i < level - 1)
                    {
                        if (visible[i])
                            ret += "|  ";
                        else
                            ret += "   ";
                        i++;
                    }
                    if (level > 0)
                        ret += "|--";
                    return ret;
                };
                ss << getHead(level);
                ss << node.descData();
                ss << std::endl;
                if (level > 0)
                    for (int i = level; i < visible.size(); i++)
                        visible[i] = true;
            },
            level, index);
        return ss.str();
    }

    void print()
    {
        std::cout << this->dumpTree();
    }
};
```

详情请查看源码，下面所用到的**语法解析树**就是此模板的一个实例类。

#### 2.5.2 在语法分析的过程中构建具象语法树CST

具象语法树（**Concrete Syntax Tree，CST**）是一种表示编程语言文本的语法结构树（或语法解析树），它是由编译器或解释器根据编程语言的上下文无关文法和词法分析器生成的。CST **反映了源代码的具体结构**，包含了语言的**所有细节和特性**，方便编译器或解释器进行后续的语义分析和代码生成。

CST 通常由一个或多个节点组成，每个节点表示源代码中的一个语法结构，如变量声明、函数定义、循环语句等。节点之间的关系通过边来表示，例如父子关系、兄弟关系等。CST 的**根节点代表整个程序**，而**叶子节点则代表程序中最基本的语法单位**，如标识符、操作符等。

CST 与抽象语法树（AST）相似，但它们有一些不同之处。CST 包含了源代码中的**所有细节和特性**，包括关键字、括号等，而 AST 则去除了这些细节，只保留了源代码中的**重要语义结构**。CST 还包含了**类型信息和位置信息**，方便后续的语义分析和代码生成。

以ESLR分析器为例，展示相关核心代码如下：

```C++
/**
 * @brief ESLR核心分析过程，用于解析输入的token序列并构建CST
 *
 * @param input 输入的token序列
 * @param code 上下文浏览器，这里仅用于在出错时打印相关上下文信息
 * @return true 解析成功
 * @return false 解析失败
 */
bool ExtendedSimpleLR1Parser::parse(vector<token> &input, const ContextViewer &code)
{
    info << "ExtendedSimpleLR1Parser: Parsing..." << endl;
    // 初始化，将输入的token序列添加一个结束符号
    // 将输入的token序列转换为TokenViewer，方便后续遍历
    input.push_back(token(make_shared<symbol_t>(SYM_END), SYM_END, 0, 0));
    TokenViewer viewer(input);
    // 初始化栈
    stack<symbol_t> symStk;       // 符号栈
    stack<state_id_t> stateStk;   // 状态栈
    stack<pst_node_ptr_t> cstStk; // 解析树栈（CST）
    symStk.push(SYM_END);         // 符号栈初始加入结束符号
    stateStk.push(0);             // 状态栈初始加入状态 0
    // 初始化表头（用于打印输出分析过程）
    tb_head | "Symbol/State" | "Input" | "Action";
    set_row | AL_CTR;
    token &tok = viewer.current();
    while (!stateStk.empty() && !symStk.empty() && !viewer.ends())
    {
        // 逐步遍历输入流，直到输入流结束
        tok = viewer.current();                         // 获取输入流的当前token
        state_id_t s = stateStk.top();                  // 获取状态栈的栈顶状态
        symbol_t a = *(tok.type);                       // 获取输入流的当前token代表的终结符
        action_t &act = grammar.slr1Table[mkcrd(s, a)]; // 获取当前状态和当前终结符在SLR1分析表中对应的动作
        // 打印输出分析过程
        string act1, act2;
        tie(act1, act2) = descAction(act); // 将动作转换为字符串，用于打印输出
        // 将当前符号栈、状态栈、输入流和动作添加到打印表格中
        new_row | Cell(descStack(symStk)) & AL_LFT | Cell(a) & AL_LFT | Cell(act1) & AL_LFT;
        new_row | descStack(stateStk) | Cell(descTokVecFrom(input, viewer.pos())) & AL_RGT | Cell(act2) & AL_RGT;
        tb_line();
        // 根据动作类型进行相应的处理
        if (holds_alternative<shift_t>(act))
        {
            // 移进动作
            shift_t shift = get<shift_t>(act); // 获取移进动作对应的状态
            symStk.push(a);                    // 将当前终结符压入符号栈
            stateStk.push(shift);              // 将移进动作对应的状态压入状态栈
            // 创建一个新的CST叶子节点，将当前终结符作为其数据
            pst_node_ptr_t node = pst_tree_t::createNode(TERMINAL, tok.value, tok.line, tok.col);
            cstStk.push(node); // 将新的CST节点压入解析树栈
            viewer.advance();  // 将输入流向前移动一个token
        }
        else if (holds_alternative<reduce_t>(act))
        {
            // 规约动作
            product_t &reduce = get<reduce_t>(act).get(); // 获取规约动作对应的产生式
            symbol_t left = reduce.first;                 // 获取产生式左部
            symstr_t right = reduce.second;               // 获取产生式右部
            size_t len = right.size();                    // 获取产生式右部长度（即规约长度）
            // 创建一个新的CST非叶子节点，将产生式左部作为其数据
            // 该节点的子节点为规约长度个数的CST节点，这些CST节点是从解析树栈中弹出的
            pst_node_ptr_t node = pst_tree_t::createNode(NON_TERM, left, 0, 0);
            node->attachProduct(reduce); // 将产生式信息附加到新的CST节点上，便于后续构建RST和AST
            for (size_t i = 0; i < len; i++)
            {
                // 从解析树栈中弹出规约长度个数的CST节点，并添加到新的CST节点中
                // 这里是逆序添加，因为解析树栈中的CST节点是按照规约顺序压入的
                // 符号栈和状态栈中的元素也相应地弹出
                symStk.pop();
                stateStk.pop();
                *node << cstStk.top();
                cstStk.pop();
            }
            // 将新的CST节点的子节点顺序逆转，保证其顺序与产生式右部一致
            node->reverseChildren();
            symStk.push(left); // 将产生式左部压入符号栈
            cstStk.push(node); // 将新的CST节点压入解析树栈
            // 根据产生式左部和当前状态在goto表中查找，得到下一个状态
            action_t &nAct = grammar.slr1Table[mkcrd(stateStk.top(), left)];
            if (holds_alternative<shift_t>(nAct))
                stateStk.push(get<shift_t>(nAct)); // 如果下一个状态是移进状态，将新的状态号压入状态栈
            else if (holds_alternative<accept_t>(nAct) && get<accept_t>(nAct))
                goto accept; // 如果下一个状态是接受状态，说明分析成功，跳转到接受处理部分
            else
                goto reject; // 如果下一个状态是错误状态，说明分析失败，跳转到拒绝处理部分
        }
        // 接受动作
        else if (holds_alternative<accept_t>(act) && get<accept_t>(act))
            goto accept;
        else // 错误动作
            goto reject;
    }
reject: // 拒绝处理部分
    error << "ExtendedSimpleLR1Parser: Parsing failed!" << endl;
    new_row | TB_TAB | MD_TAB | Cell("Rejected") & FORE_RED;
    std::cout << tb_view(); // 打印输出分析表格
    info << "ExtendedSimpleLR1Parser: Related context:" << endl;
    tok = viewer.current();               // 获取当前token
    code.printContext(tok.line, tok.col); // 打印当前Token的相关上下文信息
    info << "ExtendedSimpleLR1Parser: Remaining cst nodes:" << endl;
    // 打印输出分析栈中剩余的CST节点，便于找出问题
    printRemainingTreeNodes(cstStk);
    return false;
accept: // 接受处理部分
    info << "ExtendedSimpleLR1Parser: Parsing succeed!" << endl;
    // 获取文法开始符号对应的产生式
    grammar.updateStartProduct();
    product_t &startProduct = grammar.startProduct;
    symstr_t &right = startProduct.second;
    // 创建一个新的CST根节点（整个CST的根节点），将文法开始符号作为其数据
    pst_node_ptr_t startNode = pst_tree_t::createNode(NON_TERM, grammar.symStart, 0, 0);
    startNode->attachProduct(startProduct); // 将文法开始符号对应的产生式信息附加到新的CST节点上
    for (size_t i = 0; i < right.size(); i++)
    {
        // 从解析树栈中弹出规约长度个数的CST节点，并添加到CST根节点中
        symStk.pop();
        stateStk.pop();
        *startNode << cstStk.top();
        cstStk.pop();
    }
    // 将CST根节点的子节点顺序逆转，保证其顺序与产生式右部一致
    startNode->reverseChildren();
    // 最终CST树的根节点即为文法开始符号对应的CST节点
    cst = startNode;
    // 打印输出分析表格
    new_row | Cell(descStack(symStk)) & AL_LFT | MD_TAB | Cell("Accepted") & FORE_GRE;
    std::cout << tb_view();
    return true;
}
```

上述过程分析得到的CST的部分结果如下：

```
Program <Program -> Program_star_1>
|--Program_star_1 <Program_star_1 -> FuncDeclStmt Program_star_1>
   |--FuncDeclStmt <FuncDeclStmt -> decl FuncDecl ;>
   |  |--`decl` at <5:4>
   |  |--FuncDecl <FuncDecl -> func Ident ( FuncDecl_opti_1 ) FuncDecl_opti_2>
   |  |  |--`func` at <5:9>
   |  |  |--`add` at <5:13>
   |  |  |--`(` at <5:14>
   |  |  |--FuncDecl_opti_1 <FuncDecl_opti_1 -> ParamList>
   |  |  |  |--ParamList <ParamList -> Param ParamList_star_1>
   |  |  |     |--Param <Param -> Ident : VarType Param_star_1>
   |  |  |     |  |--`x` at <5:15>
   |  |  |     |  |--`:` at <5:17>
   |  |  |     |  |--VarType <VarType -> int>
   |  |  |     |  |  |--`int` at <5:21>
   |  |  |     |  |--Param_star_1 <Param_star_1 -> >
   |  |  |     |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
   |  |  |        |--`,` at <5:22>
   |  |  |        |--Param <Param -> Ident : VarType Param_star_1>
   |  |  |        |  |--`y` at <5:24>
   |  |  |        |  |--`:` at <5:26>
   |  |  |        |  |--VarType <VarType -> int>
   |  |  |        |  |  |--`int` at <5:30>
   |  |  |        |  |--Param_star_1 <Param_star_1 -> >
   |  |  |        |--ParamList_star_1 <ParamList_star_1 -> >
```

观察上述CST可以发现，其中信息非常丰富，但包含了许多我们并不关心乃至并不想要的内容。这部分信息主要包括两点。

其一，我们不需要诸如`for`、`while`、`(`等**关键字或者运算符**信息。这些信息本质上是用来**辅助语法分析器归纳语义结构**的，但在我们后序的分析阶段这些并不重要。我们可以通过CST上的非终结符结点来获知当前结点的语义结构，而无需通过这些关键词去识别。因此，这部分信息需要从树上**抹除**。上述CST精简后可以得到如下结构：

```
Program <Program -> Program_star_1>
|--Program_star_1 <Program_star_1 -> FuncDeclStmt Program_star_1>
   |--FuncDeclStmt <FuncDeclStmt -> decl FuncDecl ;>
   |  |--FuncDecl <FuncDecl -> func Ident ( FuncDecl_opti_1 ) FuncDecl_opti_2>
   |     |--`add` at <5:13>
   |     |--FuncDecl_opti_1 <FuncDecl_opti_1 -> ParamList>
   |     |  |--ParamList <ParamList -> Param ParamList_star_1>
   |     |     |--Param <Param -> Ident : VarType Param_star_1>
   |     |     |  |--`x` at <5:15>
   |     |     |  |--VarType <VarType -> int>
   |     |     |  |  |--`int` at <5:21>
   |     |     |  |--Param_star_1 <Param_star_1 -> >
   |     |     |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
   |     |        |--Param <Param -> Ident : VarType Param_star_1>
   |     |        |  |--`y` at <5:24>
   |     |        |  |--VarType <VarType -> int>
   |     |        |  |  |--`int` at <5:30>
   |     |        |  |--Param_star_1 <Param_star_1 -> >
   |     |        |--ParamList_star_1 <ParamList_star_1 -> >
```

其二，CST上的某些节点结构并不便于我们分析。EBNF为我们提供了**重复和可选**的表达语义，语法分析器实际上是需要先将根据这些语义生成相应的新的产生式才能完成语义分析的。这些产生式是**程序额外添加进来**的，并不是我们所掌握的信息。例如，我们不希望得到类似下面的**递归**结构：

```
|--ParamList <ParamList -> Param ParamList_star_1>
   |--Param <Param -> Ident : VarType Param_star_1>
   |  |--`x` at <6:16>
   |  |--VarType <VarType -> int>
   |  |  |--`int` at <6:22>
   |  |--Param_star_1 <Param_star_1 -> >
   |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
      |--Param <Param -> Ident : VarType Param_star_1>
      |  |--`y` at <6:25>
      |  |--VarType <VarType -> int>
      |  |  |--`int` at <6:31>
      |  |--Param_star_1 <Param_star_1 -> >
      |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
         |--Param <Param -> Ident : VarType Param_star_1>
         |  |--`z` at <6:34>
         |  |--VarType <VarType -> real>
         |  |  |--`real` at <6:41>
         |  |--Param_star_1 <Param_star_1 -> >
         |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
            |--Param <Param -> Ident : VarType Param_star_1>
            |  |--`s` at <6:44>
            |  |--VarType <VarType -> str>
            |  |  |--`str` at <6:50>
            |  |--Param_star_1 <Param_star_1 -> >
            |--ParamList_star_1 <ParamList_star_1 -> >
```

而希望程序能够**隐去**其自动添加的产生式（也就是让这部分对用户**透明**），帮我们整理成如下格式：

```
|--ParamList <ParamList -> Param ParamList_star_1>
   |--Param <Param -> Ident : VarType Param_star_1>
   |  |--`x` at <6:16>
   |  |--VarType <VarType -> int>
   |  |  |--`int` at <6:22>
   |  |--StarList <Param_star_1 -> >
   |--Param <Param -> Ident : VarType Param_star_1>
   |  |--`y` at <6:25>
   |  |--VarType <VarType -> int>
   |  |  |--`int` at <6:31>
   |  |--StarList <Param_star_1 -> >
   |--Param <Param -> Ident : VarType Param_star_1>
   |  |--`z` at <6:34>
   |  |--VarType <VarType -> real>
   |  |  |--`real` at <6:41>
   |  |--StarList <Param_star_1 -> >
   |--Param <Param -> Ident : VarType Param_star_1>
      |--`s` at <6:44>
      |--VarType <VarType -> str>
      |  |--`str` at <6:50>
      |--StarList <Param_star_1 -> >
```

#### 2.5.3 删去CST中冗余信息得到简化语法树RST

经过了上述观察，我们便确定了努力方向。

首先简化CST得到RST，相关核心代码和说明如下：

```C++
/**
 * @brief 精简CST，将其转换为RST
 *
 * @return pst_tree_ptr_t 精简后的RST根节点
 */
pst_tree_ptr_t ExtendedSimpleLR1Parser::reduceCST()
{
    info << "ExtendedSimpleLR1Parser: Reducing CST... (CST->RST)" << endl;
    const Grammar &g = this->grammar;
    symset_t &mulTerms = grammar.mulTerms;
    symset_t &nonTerms = grammar.nonTerms;
    symset_t &terminals = grammar.terminals;
    // 用于构建RST的节点栈
    // 这里并不是在原来的CST上进行修改，而是在遍历CST的过程中挑选有用的信息构建新的RST
    stack<pst_node_ptr_t> rstStk;
    // 后序遍历CST，同时利用栈保存遍历过程中的节点，自底向上构建RST
    cst->postorder(
        [&](pst_node_t node)
        {
            // 创建新的RST节点
            pst_node_ptr_t rstNode = pst_tree_t::createNode(node.data);
            // 如果当前节点代表非终结符，按照其产生式构造简化的RST节点
            // 因为是后序遍历，所以子节点已经被压入栈中了
            // 如果当前节点代表终结符，直接压入栈中并返回即可
            if (node.data.type == NON_TERM)
            {
                assert(node.data.product_opt.has_value());
                product_t &product = node.data.product_opt.value();
                symstr_t &right = product.second;
                rstNode->attachProduct(product);
                // 如果产生式右部只有一个终结符，那么将其作为RST节点的数据保留
                if (right.size() == 1 && _find(terminals, right[0]))
                {
                    pst_node_ptr_t child = rstStk.top();
                    rstStk.pop();
                    *rstNode << child;
                }
                else
                {
                    // 逆序遍历子节点，将其弹出栈并添加到新的RST节点中
                    for (auto it = right.rbegin(); it != right.rend(); it++)
                    {
                        pst_node_ptr_t child = rstStk.top();
                        rstStk.pop();
                        // RST节点仅保留非终结符（non-term）和带有映射信息的字面量终结符（mul-term）
                        if (_find(nonTerms, *it) || _find(mulTerms, *it))
                        {
                            *rstNode << child;
                        }
                    }
                    // 逆转子节点顺序
                    rstNode->reverseChildren();
                }
            }
            // 将新的RST节点压入栈中
            rstStk.push(rstNode);
        });
    // 最后栈中只剩下一个RST节点，即为最终的RST
    rst = rstStk.top();
    return rst;
}
```

上面的代码主要利用了我实现的抽象树的**后序遍历**方法，并在遍历的过程中传入一个**Lambda匿名函数**，在遍历CST的**同时**构建出精简的RST。

#### 2.5.4 重构RST的语义结构得到抽象语法树AST

得到RST后，我们考虑将其重构，识别其中的递归重复和可选结构，将其重组为新的结构。

对于**递归重复**的结构，我们做如下处理：

```C++
/**
 * @brief 重构AST节点，将该节点的右递归子节点平铺
 *
 * @param astNode 需要处理的AST节点
 * @param indexes 需要处理的子节点的索引
 */
void refactorStarListNode(pst_node_ptr_t astNode, vector<size_t> indexes)
{
    for (auto idx : indexes)
    {
        pst_node_ptr_t target = astNode->getChildAt(idx);
        // 创建一个新的AST节点，将原来的子节点遍历处理后添加到新的节点中
        pst_node_ptr_t listNode = pst_tree_t::createNode(target->data);
        // 新节点的命名为StarList，便于后续处理
        listNode->data.symbol = "StarList";
        // 递归遍历子节点
        function<void(pst_node_ptr_t)> traverse = [&](pst_node_ptr_t node)
        {
            const vector<pst_node_ptr_t> &children = node->getChildren();
            if (children.size() > 0)
            {
                // 将各层的非右递归子节点直接平铺添加的要处理的根节点中
                for (int i = 0; i < children.size() - 1; i++)
                {
                    *listNode << children[i];
                }
                // 在右递归的子结点中，最后一个子结点还是右递归的子结点
                traverse(children.back());
            }
        };
        traverse(target);
        // 用新节点替换原来的节点
        astNode->replace(idx, listNode);
        // 下面进行AST简化整合
        if (astNode->getChildren().size() == 1)
        {
            // 如果当前节点只有一个子节点，说明其只有一个ListNode节点
            // 此时删掉ListNode节点，将其子节点提升到当前节点
            const vector<pst_node_ptr_t> &children = listNode->getChildren();
            astNode->pop_back();
            for (auto &child : children)
            {
                *astNode << child;
            }
        }
        else if (astNode->getChildren().size() == 2)
        {
            // 如果当前节点有两个子节点，说明其有一个ListNode节点和一个非ListNode节点
            // 此时判断非ListNode节点是否与ListNode节点的子节点是同类型
            // 如果是，则将ListNode子节点提升到当前节点，删掉ListNode节点
            const vector<pst_node_ptr_t> &children = listNode->getChildren();
            pst_node_ptr_t nonListNode = astNode->getChildAt(0);
            if (children.size() == 0)
            {
                astNode->pop_back();
                continue;
            }
            if (nonListNode->data.symbol == children[0]->data.symbol)
            {
                astNode->pop_back();
                for (auto &child : children)
                {
                    *astNode << child;
                }
            }
        }
    }
}
```

对于**可选结构**，我们只需做一些**标记**即可：

```C++
/**
 * @brief 重构AST节点，将该节点的可选子节点标记为Optional
 *
 * @param astNode 需要处理的AST节点
 * @param indexes 需要处理的子节点的索引
 */
void refactorOptionalNode(pst_node_ptr_t astNode, vector<size_t> indexes)
{
    vector<pst_node_ptr_t> &children = astNode->getChildren();
    for (auto idx : indexes)
    {
        children[idx]->data.symbol = "Optional";
    }
}
```

再有了上面两个处理方法的基础上，我们遍历RST，一边识别其复合的结构特征，一边**自底向上**重新构筑AST：

```C++
/**
 * @brief 重构RST，将其转换为AST
 *
 * @return pst_tree_ptr_t 重构后的AST根节点
 */
pst_tree_ptr_t ExtendedSimpleLR1Parser::refactorRST()
{
    info << "ExtendedSimpleLR1Parser: Refactoring RST... (RST->AST)" << endl;
    // 用于构建AST的节点栈
    // 重构的思路与精简CST类似，依然是在遍历RST的过程构建新的AST
    // 只是这里是并不是挑选有用的信息，而是构建的同时调用相应的函数进行重构处理
    stack<pst_node_ptr_t> astStk;
    // 后序遍历RST，同时利用栈保存遍历过程中的节点，自底向上构建AST
    rst->postorder(
        [&](pst_node_t node)
        {
            // 创建新的AST节点
            pst_node_ptr_t astNode = pst_tree_t::createNode(node.data);
            // 如果当前节点代表非终结符，先将栈中的子节点弹出并添加到新的AST节点中
            // 而后检查其产生式是否包含特殊非终结符（隐含有运算符信息）
            // 如果包含，则调用相应的函数进行处理
            // 如果当前节点代表终结符，直接压入栈中并返回即可
            if (node.data.type == NON_TERM)
            {
                assert(node.data.product_opt.has_value());
                product_t &product = node.data.product_opt.value();
                // 将产生式简化为仅包含有用信息的产生式
                reduced_product_t reducedProduct = grammar.reduceProduct(product);
                symbol_t &left = reducedProduct.first;
                symstr_t &right = reducedProduct.second;
                // 记录产生式中特殊非终结符的位置
                // 特殊非终结符包括：_star_（表示0或多次）、_opti_（表示0或1次）
                // 这些特殊的非终结符是在EBNF解析的过程中添加的
                // 在语法分析时，这些特殊非终结符会被记录在CST中
                // 在完成语法分析后，这些程序自动添加的特殊非终结符就可以被删除了
                // 最后只留下用户自定义的非终结符构成的AST，便于后续语义分析的过程
                static vector<size_t> starIndexes, optiIndexes;
                starIndexes.clear();
                optiIndexes.clear();
                // 逆序遍历子节点，将其弹出栈并添加到新的AST节点中
                for (size_t i = right.size() - 1; i != -1; i--)
                {
                    symbol_t &s = right[i];
                    pst_node_ptr_t child = astStk.top();
                    astStk.pop();
                    *astNode << child;
                    // 如果右部有特殊非终结符，记录其位置
                    if (s.find("_star_") != string::npos)
                    {
                        starIndexes.push_back(i);
                    }
                    else if (s.find("_opti_") != string::npos)
                    {
                        optiIndexes.push_back(i);
                    }
                }
                // 逆转子节点顺序
                astNode->reverseChildren();
                // 处理特殊非终结符
                // 如果左部有特殊非终结符，说明不需要做额外处理
                // 因为我们需要向上找到第一个不含特殊非终结符的左部产生式，再统一处理
                if (optiIndexes.size() > 0)
                    refactorOptionalNode(astNode, optiIndexes); // 处理Optional节点
                if (left.find("_star_") == string::npos && starIndexes.size() > 0)
                    refactorStarListNode(astNode, starIndexes); // 处理StarList节点
            }
            // 将新的RST节点压入栈中
            astStk.push(astNode);
        });
    // 最后栈中只剩下一个AST节点，即为最终的AST
    ast = astStk.top();
    return ast;
}
```

经过上述步骤得到的AST，就可以进行下一步的处理了。

### 2.6 类LLVM IR的中间表示生成

关于中间表示，我采用了LLVM IR的规范。这个IR本质上仍是**三地址码**，只不过能够关注更多的细节，并且在**工程实践上更有实际价值**。

#### 2.6.1 LLVM IR简介

LLVM IR（**LLVM Intermediate Representation**）是 LLVM （Low-Level Virtual Machine）编译器框架中的一种中间代码表示形式，它**类似于汇编语言**，但比汇编语言更高级，但比常见的编程语言更低级。

LLVM IR 的设计初衷是为了提供一种通用的中间代码表示形式，可以被多种编程语言的前端所使用，并且可以被编译成多种目标平台的机器码。LLVM IR 具有以下特点：

1. 类型安全：LLVM IR 代码中的每个值都有一个明确的类型，并且类型检查是在编译时进行的，可以帮助开发者避免类型错误。
2. 抽象：LLVM IR 代码中的指令和操作符可以看作是高级语言中的语法结构，可以方便地表示程序的逻辑结构和算法。
3. 可移植性：LLVM IR 代码可以被编译成多种目标平台的机器码，具有**很好的可移植性和可扩展性**。

在 LLVM 编译器框架中，LLVM IR 通常是前端将源代码编译成的中间代码表示形式，经过优化和转换后再生成目标平台的机器码。同时，LLVM IR 代码也可以手动编写，用于实现一些特殊的编译器优化或调试功能。

使用 LLVM IR 作为个人实现编译器的输出结果有以下优势：

1. 简单：LLVM IR 代码比目标平台的汇编语言更容易理解和调试，可以帮助开发者更快速地实现编译器的各个阶段。
2. 可移植：LLVM 编译器可以将 LLVM IR 代码编译成多种目标平台的机器码，可以帮助开发者更方便地测试和验证编译器的正确性和性能。
3. 高效：LLVM 编译器框架具有优秀的优化能力，可以将 LLVM IR 代码优化成更高效的机器码，从而提高程序的性能。

#### 2.6.2 RSC类型数据引用链体系设计

在进行**中间代码生成**的过程中，我刻意考虑了**后端代码优化**所需要的信息，设计并实现了**类型数据引用链**。其本质是**一组继承关系**，标记了值和指令互相之间的**使用关系**，有助于后序分析数据流等**优化**操作。

涉及到的核心数据声明如下：

```C++
class Value;
class User;
class Use;
using use_ptr_t = std::shared_ptr<Use>;
#define make_use(value, user) std::make_shared<Use>(value, user)
using user_ptr_t = std::shared_ptr<User>;
#define make_user(type, name) std::make_shared<User>(type, name)
using value_ptr_t = std::shared_ptr<Value>;
#define make_value(type, name) std::make_shared<Value>(type, name)
```

在这里，Value代表值的概念，三地址码（或者是LLVM的指令）本质上都是Value，他们有自己的名字和类型，并支持作为值被其他指令引用。User继承自Value，是所有指令的基类。Use代表User和Value的引用关系，用于后端代码优化。

相应的，还有针对RSC设计的类型系统，简要定义如下：

```C++
class Type;
using type_ptr_t = std::shared_ptr<Type>;

class PrimitiveType;
using prim_ptr_t = std::shared_ptr<PrimitiveType>;
#define make_prime_type(type) std::make_shared<PrimitiveType>(type)

class PointerType;
using ptr_ptr_t = std::shared_ptr<PointerType>;
#define make_ptr_type(type) std::make_shared<PointerType>(type)
```

由于时间和篇幅不足，这部分不再展开讨论，感兴趣请参阅源码。

#### 2.6.3 符号表和分析上下文的设计

RSC支持作用域的概念。在语义分析过程中，Visitor会维护一个上下文，上下文中存储了遍历不同节点时需要共享的信息。其中之一便是符号表。

符号表的定义如下：

```C++
using scope_t = NestedMap<std::string, user_ptr_t>;
using scope_ptr_t = std::shared_ptr<scope_t>;

class SymbolTable
{
    std::stack<scope_ptr_t> tableStk;

public:
    void newScope();
    std::list<user_ptr_t> popScope();
    [[nodiscard]] user_ptr_t find(const std::string &name);
    [[nodiscard]] user_ptr_t registerAlloca(const std::string &name, type_ptr_t type);
    [[nodiscard]] user_ptr_t registerGlobal(const std::string &name, type_ptr_t type, const_val_ptr_t init);
};
```

可见，符号表的本质是一个**作用域栈**。在这里，**作用域的**本质是`NestedMap`，即可以**递归嵌套的哈希表**。这样的数据结构，保证了我们可以在子作用域中访问父作用域的符号信息，而不能相反。进入一个作用域时，程序可以调用`newScope`函数得到全新的子作用域，退出时可以调用`popScope`弹出作用域并获取该子作用域中的所有符号定义。顺带一提，全局变量本质上是在根作用域上定义的符号变量。

Visitor上下文中，除了符号表，还有管理函数声明的函数表，其定义如下：

```C++
class FunctionTable
{
    std::map<std::string, func_ptr_t> table;

public:
    void insert(const std::string &name, func_ptr_t func) { table.insert({name, func}); }
    [[nodiscard]] func_ptr_t find(const std::string &name) const
    {
        auto it = table.find(name);
        if (it != table.end())
        {
            return it->second;
        }
        return nullptr;
    }
    [[nodiscard]] bool has(const std::string &name) const { return table.find(name) != table.end(); }
    [[nodiscard]] func_ptr_t registerFunction(const std::string &name, prim_ptr_t type)
    {
        func_ptr_t func = make_func(name, type);
        table.insert({name, func});
        return func;
    }
};
```

时间原因，不展开讲解。

#### 2.6.4 LLVM Instruction设计与定义

下面给出了我实现的LLVM指令的声明，定义请查看源码。

```C++
class LabelInstr;
using label_ptr_t = std::shared_ptr<LabelInstr>;
#define make_label(name) std::make_shared<LabelInstr>(name)
#define cast_label(instr) std::dynamic_pointer_cast<LabelInstr>(instr)

// Memory Access and Addressing Operations （内存访问和寻址操作）
class AllocaInstr;
using alloca_ptr_t = std::shared_ptr<AllocaInstr>;
#define make_alloca(name, type) std::make_shared<AllocaInstr>(name, type)
#define cast_alloca(instr) std::dynamic_pointer_cast<AllocaInstr>(instr)

class GlobalInstr;
using global_ptr_t = std::shared_ptr<GlobalInstr>;
#define make_global(name, type, value) std::make_shared<GlobalInstr>(name, type, value)
#define cast_global(instr) std::dynamic_pointer_cast<GlobalInstr>(instr)

class LoadInstr;
using load_ptr_t = std::shared_ptr<LoadInstr>;
#define make_load(from) std::make_shared<LoadInstr>(from)
#define cast_load(instr) std::dynamic_pointer_cast<LoadInstr>(instr)

class StoreInstr;
using store_ptr_t = std::shared_ptr<StoreInstr>;
#define make_store(from, to) std::make_shared<StoreInstr>(from, to)
#define cast_store(instr) std::dynamic_pointer_cast<StoreInstr>(instr)

class GEPInstr; // GetElementPtr
using gep_ptr_t = std::shared_ptr<GEPInstr>;

// Function Call Instructions （函数调用和返回指令）
class FuncInstr; // 抽象指令，由其他指令组合而成
using func_ptr_t = std::shared_ptr<FuncInstr>;
#define make_func(name, retType) std::make_shared<FuncInstr>(name, retType)
#define cast_func(instr) std::dynamic_pointer_cast<FuncInstr>(instr)

class CallInstr;
using call_ptr_t = std::shared_ptr<CallInstr>;
#define make_call(func) std::make_shared<CallInstr>(func)
#define cast_call(instr) std::dynamic_pointer_cast<CallInstr>(instr)

// Terminator Instructions （终端指令）
class RetInstr;
using ret_ptr_t = std::shared_ptr<RetInstr>;
#define make_ret(retval) std::make_shared<RetInstr>(retval)
#define cast_ret(instr) std::dynamic_pointer_cast<RetInstr>(instr)

class BrInstr;
using br_ptr_t = std::shared_ptr<BrInstr>;
#define make_br(cond) std::make_shared<BrInstr>(cond)
#define cast_br(instr) std::dynamic_pointer_cast<BrInstr>(instr)

class JmpInstr; // 无条件跳转
using jmp_ptr_t = std::shared_ptr<JmpInstr>;
#define make_jmp(target) std::make_shared<JmpInstr>(target)
#define cast_jmp(instr) std::dynamic_pointer_cast<JmpInstr>(instr)

// Unary Operations （一元运算）
class NegInstr;
using neg_ptr_t = std::shared_ptr<NegInstr>;
#define make_neg(from, opType) std::make_shared<NegInstr>(from, opType)
#define cast_neg(instr) std::dynamic_pointer_cast<NegInstr>(instr)

// Binary Operations （二元运算）
class AddInstr;
using add_ptr_t = std::shared_ptr<AddInstr>;
#define make_add(lhs, rhs, opType) std::make_shared<AddInstr>(lhs, rhs, opType)
#define cast_add(instr) std::dynamic_pointer_cast<AddInstr>(instr)

class SubInstr;
using sub_ptr_t = std::shared_ptr<SubInstr>;
#define make_sub(lhs, rhs, opType) std::make_shared<SubInstr>(lhs, rhs, opType)
#define cast_sub(instr) std::dynamic_pointer_cast<SubInstr>(instr)

class MulInstr;
using mul_ptr_t = std::shared_ptr<MulInstr>;
#define make_mul(lhs, rhs, opType) std::make_shared<MulInstr>(lhs, rhs, opType)
#define cast_mul(instr) std::dynamic_pointer_cast<MulInstr>(instr)

class DivInstr;
using div_ptr_t = std::shared_ptr<DivInstr>;
#define make_div(lhs, rhs, opType) std::make_shared<DivInstr>(lhs, rhs, opType)
#define cast_div(instr) std::dynamic_pointer_cast<DivInstr>(instr)

class RemInstr;
using rem_ptr_t = std::shared_ptr<RemInstr>;
#define make_rem(lhs, rhs, opType) std::make_shared<RemInstr>(lhs, rhs, opType)
#define cast_rem(instr) std::dynamic_pointer_cast<RemInstr>(instr)

class CmpInstr;
using cmp_ptr_t = std::shared_ptr<CmpInstr>;
#define make_cmp(lhs, rhs, opType, cmpType) std::make_shared<CmpInstr>(lhs, rhs, opType, cmpType)
#define cast_cmp(instr) std::dynamic_pointer_cast<CmpInstr>(instr)

// Block and Program
class InstrBlock;
using block_ptr_t = std::shared_ptr<InstrBlock>;
#define make_block(name) std::make_shared<InstrBlock>(name)
#define cast_block(instr) std::dynamic_pointer_cast<InstrBlock>(instr)

class Program;
using program_ptr_t = std::shared_ptr<Program>;
#define make_program() std::make_shared<Program>()
#define cast_program(instr) std::dynamic_pointer_cast<Program>(instr)

// Constant Values
class Constant;
using const_val_ptr_t = std::shared_ptr<Constant>;
#define cast_const(instr) std::dynamic_pointer_cast<Constant>(instr)

class ConstantInt;
using const_int_ptr_t = std::shared_ptr<ConstantInt>;
#define make_const_int(value) std::make_shared<ConstantInt>(value)

class ConstantReal;
using const_real_ptr_t = std::shared_ptr<ConstantReal>;
#define make_const_real(value) std::make_shared<ConstantReal>(value)

class ConstantBool;
using const_bool_ptr_t = std::shared_ptr<ConstantBool>;
#define make_const_bool(value) std::make_shared<ConstantBool>(value)

class ConstantChar;
using const_char_ptr_t = std::shared_ptr<ConstantChar>;
#define make_const_char(value) std::make_shared<ConstantChar>(value)

class ConstantString;
using const_str_ptr_t = std::shared_ptr<ConstantString>;
#define make_const_str(value) std::make_shared<ConstantString>(value)
```

时间原因，不展开讲解。

#### 2.6.5 AST Visitor模式设计与实现

下面给出了Visitor的定义，实现请查看源码：

```C++
class RSCVisitor
{
    Context context;

public:
    program_ptr_t visitProgram(pst_node_ptr_t node);

    ret_info_t visitVarDeclStmt(pst_node_ptr_t node, bool global = false);
    ret_info_t visitVarDecl(pst_node_ptr_t node, bool global = false);
    ret_info_t visitVarDef(pst_node_ptr_t node, bool global = false);

    ret_info_t visitInitVal(pst_node_ptr_t node);

    ret_info_t visitFuncDeclStmt(pst_node_ptr_t node);
    ret_info_t visitFuncDecl(pst_node_ptr_t node);
    ret_info_t visitFuncDef(pst_node_ptr_t node);
    ret_info_t visitFuncCall(pst_node_ptr_t node);

    ret_info_t visitArgList(pst_node_ptr_t node);
    ret_info_t visitParamList(pst_node_ptr_t node);
    ret_info_t visitParam(pst_node_ptr_t node);

    ret_info_t visitStmt(pst_node_ptr_t node);
    ret_info_t visitBlock(pst_node_ptr_t node);
    ret_info_t visitAssignment(pst_node_ptr_t node);
    ret_info_t visitIfStmt(pst_node_ptr_t node);
    ret_info_t visitWhileStmt(pst_node_ptr_t node);
    ret_info_t visitForStmt(pst_node_ptr_t node);
    ret_info_t visitBreakStmt(pst_node_ptr_t node);
    ret_info_t visitContinueStmt(pst_node_ptr_t node);
    ret_info_t visitReturnStmt(pst_node_ptr_t node);
    ret_info_t visitExprStmt(pst_node_ptr_t node);

    ret_info_t visitUnaryExpr(pst_node_ptr_t node);
    ret_info_t visitMulExpr(pst_node_ptr_t node);
    ret_info_t visitExpr(pst_node_ptr_t node);
    ret_info_t visitRelExpr(pst_node_ptr_t node);
    ret_info_t visitAndExpr(pst_node_ptr_t node);
    ret_info_t visitOrExpr(pst_node_ptr_t node);
    ret_info_t visitBoolExpr(pst_node_ptr_t node);

    // factors
    ret_info_t visitFactor(pst_node_ptr_t node);
    ret_info_t visitLVal(pst_node_ptr_t node);
    ret_info_t visitLiteral(pst_node_ptr_t node);
};
```

时间原因，不展开讲解。下面会针对几个比较典型的情况佐以说明。

##### 2.6.5.1 算数和逻辑表达式的翻译

算术表达式典型：

```C++
// MulExpr -> MulExpr ( `*` | `/` | `%` ) UnaryExpr | UnaryExpr
ret_info_t RSCVisitor::visitMulExpr(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting mul expr..." << std::endl;
    assert(
        node->data.symbol == "MulExpr",
        format("Expected node MulExpr, but got $ instead.", node->data.symbol));
    pst_node_ptr_t child = node->firstChild();
    if (child->data.symbol == "UnaryExpr")
    {
        // UnaryExpr
        return visitUnaryExpr(child);
    }

    assert(
        child->data.symbol == "MulExpr",
        format(
            "first child of mul expr should be mul expr or unary expr, but got $",
            child->data.symbol));
    // MulExpr ( `*` | `/` | `%` ) UnaryExpr
    assert(
        node->childrenCount() == 2,
        format("mul expr should have 1 or 2 child(ren), but got $", node->childrenCount()));

    auto lhsInfo = visitMulExpr(child);
    auto rhsInfo = visitUnaryExpr(node->getChildAt(1));

    auto op = getProSymAt(node, 1); // * | / | %

    user_ptr_t lhs = lhsInfo.getValue();
    user_ptr_t rhs = rhsInfo.getValue();

    // 生成相关指令并追加到list之后
    user_ptr_t instr = nullptr;

    if (op == "*")
    {
        instr = make_mul(lhs, rhs, lhs->getType()->getOpType());
    }
    else if (op == "/")
    {
        instr = make_div(lhs, rhs, lhs->getType()->getOpType());
    }
    else if (op == "%")
    {
        instr = make_rem(lhs, rhs, lhs->getType()->getOpType());
    }
    else
    {
        error << "unknown operator" << std::endl;
        exit(1);
    }

    ret_info_t retInfo{list_concat(lhsInfo.instrList, rhsInfo.instrList)};
    retInfo.addInstr(instr);
    retInfo.setValue(instr);

    return retInfo;
}
```

逻辑表达式典型：

```C++
// AndExpr -> AndExpr `&&` RelExpr | RelExpr
ret_info_t RSCVisitor::visitAndExpr(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting and expr..." << std::endl;
    assert(
        node->data.symbol == "AndExpr",
        format("Expected node AndExpr, but got $ instead.", node->data.symbol));
    size_t childNum = node->childrenCount();
    pst_node_ptr_t child = node->firstChild();

    if (childNum == 1 && child->data.symbol == "RelExpr")
    {
        // AndExpr -> RelExpr
        // 直接返回RelExpr的结果即可
        return visitRelExpr(child);
    }

    assert(
        child->data.symbol == "AndExpr",
        format("first child of and expr should be AndExpr or RelExpr, but got $", child->data.symbol));

    assert(
        childNum == 2,
        format("AndExpr should have 1 or 2 child(ren), but got $", childNum));

    // 处理与运算
    auto lhsInfo = visitAndExpr(child);
    auto rhsInfo = visitRelExpr(node->getChildAt(1));

    ret_info_t lhs = lhsInfo;
    ret_info_t rhs = rhsInfo;

    // 对于与运算，需要将lhs和rhs的bb连接起来
    ret_info_t retInfo{lhs.instrList};

    retInfo.appendTrueList(rhs.getTargetsOf(JR_TRUE_EXIT));   // 将rhs的真出口作为retInfo的真出口
    retInfo.appendFalseList(lhs.getTargetsOf(JR_FALSE_EXIT)); // 将lhs的假出口作为retInfo的假出口
    retInfo.appendFalseList(rhs.getTargetsOf(JR_FALSE_EXIT)); // 将rhs的假出口作为retInfo的假出口

    // 将lhs的真出口tc连接到rhs的入口bb entry
    block_ptr_t bb = make_block("and.rhs");
    bb->addInstrList(rhs.instrList);
    retInfo.addInstr(bb);

    lhs.backpatch(JR_TRUE_EXIT, bb);

    return retInfo;
}
```

##### 2.6.5.2 函数声明、定义和调用的翻译

```C++
// FuncDef -> FuncDecl Block
ret_info_t RSCVisitor::visitFuncDef(pst_node_ptr_t node)
{
    assert(
        node->data.symbol == "FuncDef",
        format("Expected node FuncDef, but got $ instead.", node->data.symbol));
    // 首先检查函数是否已经声明
    // 如果已经声明，则需要对比函数声明和函数定义是否一致
    // 如果没有声明，则直接注册函数
    pst_node_ptr_t funcDeclNode = node->firstChild();

    const std::string &identStr = funcDeclNode->firstChild()->data.symbol;
    func_ptr_t func = context.functionTable.find(identStr);

    if (func == nullptr)
    {
        // 函数未声明，直接注册函数
        ret_info_t funcInfo = visitFuncDecl(funcDeclNode);

        func = dynamic_pointer_cast<FuncInstr>(funcInfo.getValue());
    }
    else
    {
        // 函数已声明，检查函数声明和函数定义是否一致
        std::string retTypeStr = "void";
        pst_node_ptr_t retTypeNode = funcDeclNode->getChildAt(2);
        if (retTypeNode->hasChild())
        {
            // 函数声明有返回值类型
            retTypeStr = retTypeNode->firstChild()->firstChild()->data.symbol;
        }
        pst_node_ptr_t paramsNode = funcDeclNode->getChildAt(1);
        if (paramsNode->hasChild())
        {
            // 函数声明有参数
            // 检查函数定义是否有参数
            ret_info_t paramsInfo = visitParamList(paramsNode->firstChild());

            assert(
                func->matchRetType(PrimitiveType::str2type(retTypeStr)) &&
                    func->matchArgs(paramsInfo.valueList),
                "function declaration and definition mismatch.");
        }
    }

    // 新建作用域，访问解析函数体
    context.symbolTable.newScope();

    // 注册函数参数
    for (user_ptr_t param : func->getParams())
    {
        context.symbolTable.registerAlloca(param->getName(), param->getType());
    }

    pst_node_ptr_t blockNode = node->getChildAt(1);
    ret_info_t blockInfo = visitBlock(blockNode);

    // 下面开始构建函数定义

    // 首先构建函数的入口基本块 entry basic block
    block_ptr_t entryBB = make_block("entry");
    // 将函数体内变量的内存分配指令追加到entry之后
    std::list<user_ptr_t> allocas = context.symbolTable.popScope();
    entryBB->addInstrList(allocas);
    // 为函数返回值分配内存
    // alloca_ptr_t retAlloc = make_alloca("retval", func->getRetType());
    // entryBB->addInstr(retAlloc);

    // 构建函数的出口基本块 exit basic block
    // block_ptr_t exitBB = make_block("exit");
    // 为函数返回值赋值
    // load_ptr_t loadInstr = make_load(retAlloc);
    // ret_ptr_t retInstr = make_ret(loadInstr);
    // exitBB->addInstr(loadInstr);
    // exitBB->addInstr(retInstr);

    // 构建函数的主体基本块 main basic block
    block_ptr_t mainBB = make_block("body");
    mainBB->addInstrList(blockInfo.instrList);

    // 将entry, main, exit基本块追加到函数中
    func->addBlock(entryBB);
    func->addBlock(mainBB);
    // func->addBlock(exitBB); // 意义不明，暂时不添加

    return ret_info_t{std::list<user_ptr_t>{func}}.setValue(func);
}

// FuncCall -> ident ( [ArgList] )
ret_info_t RSCVisitor::visitFuncCall(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting func call..." << std::endl;
    assert(
        node->data.symbol == "FuncCall",
        format("Expected node FuncCall, but got $ instead.", node->data.symbol));
    // 获取ident和ArgList
    std::string ident = node->getChildAt(0)->data.symbol;
    if (ident == "print")
    {
        // print函数是内置函数，暂时不生成IR
        warn << "print function is not supported yet" << std::endl;
        return ret_info_t();
    }
    // 查看函数是否已经声明
    func_ptr_t func = context.functionTable.find(ident);
    assert(func != nullptr, "function has not been declared");

    pst_node_ptr_t argListNode = node->getChildAt(1);

    ret_info_t retInfo;
    // 生成call指令并追加到list之后
    call_ptr_t callInstr = make_call(func);
    // 解析ArgList
    if (argListNode->hasChild())
    {
        ret_info_t argListInfo = visitArgList(argListNode->firstChild());
        retInfo.appendInstrList(argListInfo.instrList);
        instr_list_t &list = argListInfo.valueList;
        // 做一步类型转换，将list转换为list<user_ptr_t>
        std::list<user_ptr_t> args(list.begin(), list.end());

        // 检查参数列表是否匹配
        assert(func->matchArgs(args), "function call and declaration mismatch");

        callInstr->addArgs(args);
    }
    retInfo.addInstr(callInstr);
    retInfo.setValue(callInstr);

    return retInfo;
}
```

##### 2.6.5.3 流程控制语句的翻译

For循环：

```C++
// ForStmt -> for ( [VarDecl|Assignment] ; [BoolExpr] ; [Assignment] ) Stmt
ret_info_t RSCVisitor::visitForStmt(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting for stmt..." << std::endl;
    assert(
        node->data.symbol == "Stmt" || node->data.symbol == "Assignment",
        format("Expected node Stmt, but got $ instead.", node->data.symbol));
    context.symbolTable.newScope();
    ret_info_t retInfo;

    block_ptr_t initBB = make_block("for.init");
    block_ptr_t condBB = make_block("for.cond");
    block_ptr_t stmtBB = make_block("for.body");
    block_ptr_t lastBB = make_block("for.last");

    // 解析VarDecl|Assignment
    pst_node_ptr_t varDeclOrAssignNode = node->getChildAt(0);
    if (varDeclOrAssignNode->hasChild())
    {
        pst_node_ptr_t initNode = varDeclOrAssignNode->firstChild();
        if (initNode->data.symbol == "VarDecl")
        {
            // VarDecl
            ret_info_t varDeclInfo = visitVarDecl(initNode);
            initBB->addInstrList(varDeclInfo.instrList);
        }
        else
        {
            // Assignment
            ret_info_t assignInfo = visitAssignment(initNode);
            initBB->addInstrList(assignInfo.instrList);
        }
        retInfo.addInstr(initBB);
    }

    // 解析BoolExpr
    pst_node_ptr_t boolExprNode = node->getChildAt(1);
    if (boolExprNode->hasChild())
    {
        ret_info_t boolExprInfo = visitBoolExpr(boolExprNode->firstChild());
        condBB->addInstrList(boolExprInfo.instrList);
        retInfo.addInstr(condBB);

        // 回填BoolExpr的真出口，指向stmtBB
        boolExprInfo.backpatch(JR_TRUE_EXIT, stmtBB);

        // BoolExpr的假出口，指向for循环的出口（Fall through）
        retInfo.appendJmpList(boolExprInfo.getTargetsOf(JR_FALSE_EXIT), JR_FALL_THROUGH);
    }

    // 解析Stmt
    pst_node_ptr_t stmtNode = node->getChildAt(3);
    ret_info_t stmtInfo = visitStmt(stmtNode);
    stmtBB->addInstrList(stmtInfo.instrList);
    retInfo.addInstr(stmtBB);
    retInfo.unionGoTo(stmtInfo);

    // 解析Assignment
    pst_node_ptr_t assignNode = node->getChildAt(2);
    if (assignNode->hasChild())
    {
        ret_info_t assignInfo = visitAssignment(assignNode->firstChild());
        lastBB->addInstrList(assignInfo.instrList);
    }
    lastBB->addInstr(make_jmp(boolExprNode->hasChild() ? condBB : stmtBB));
    retInfo.addInstr(lastBB);

    // 处理Stmt中的break，指向for循环的出口（Fall through）
    retInfo.appendJmpList(retInfo.getTargetsOf(JR_BREAK_OUT), JR_FALL_THROUGH);

    // 回填Stmt中的continue，指向lastBB
    retInfo.backpatch(JR_CONTINUE, lastBB);

    auto allocas = context.symbolTable.popScope();
    initBB->addInstrListFromFront(allocas);

    return retInfo;
}
```

条件控制：

```C++
// IfStmt -> if ( BoolExpr ) Stmt [else Stmt]
ret_info_t RSCVisitor::visitIfStmt(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting if stmt..." << std::endl;
    assert(
        node->data.symbol == "Stmt",
        format("Expected node Stmt, but got $ instead.", node->data.symbol));
    // 获取BoolExpr返回值
    ret_info_t retInfo;
    ret_info_t boolInfo = visitBoolExpr(node->getChildAt(0));
    retInfo.unionGoTo(boolInfo);
    // 构造条件基本块
    block_ptr_t condBB = make_block("if.cond");
    condBB->addInstrList(boolInfo.instrList);
    retInfo.addInstr(condBB);

    // 构造条件为真时的作用域
    context.symbolTable.newScope();

    // 获取Stmt
    auto stmtInfo = visitStmt(node->getChildAt(1));

    // 将Stmt内容整合为基本块
    block_ptr_t stmtBB = make_block("if.then");
    stmtBB->addInstrList(stmtInfo.instrList);
    retInfo.addInstr(stmtBB);
    retInfo.unionGoTo(stmtInfo);

    // 绑定条件的真出口
    retInfo.backpatch(JR_TRUE_EXIT, stmtBB);

    auto trueAllocas = context.symbolTable.popScope();
    stmtBB->addInstrListFromFront(trueAllocas);

    // 获取else Stmt
    pst_node_ptr_t elseStmtNode = node->getChildAt(2);
    if (elseStmtNode->hasChild())
    {
        // 构造条件为假时的作用域
        context.symbolTable.newScope();

        ret_info_t elseStmtInfo = visitStmt(elseStmtNode->firstChild());

        // 将else Stmt内容整合为基本块
        block_ptr_t elseStmtBB = make_block("if.else");
        elseStmtBB->addInstrList(elseStmtInfo.instrList);
        retInfo.addInstr(elseStmtBB);
        retInfo.unionGoTo(elseStmtInfo);

        // 绑定条件的假出口
        retInfo.backpatch(JR_FALSE_EXIT, elseStmtBB);

        auto falseAllocas = context.symbolTable.popScope();
        elseStmtBB->addInstrListFromFront(falseAllocas);
    }
    else
    {
        // 修改条件的假出口为fall through
        retInfo.shiftReason(JR_FALSE_EXIT, JR_FALL_THROUGH);
    }

    return retInfo;
}
```

##### 2.6.5.4 立即数、局部变量和全局变量

立即数：

```C++
// Factor -> int, real, char, string, true, false
ret_info_t RSCVisitor::visitLiteral(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting literal..." << std::endl;
    // 如果node自身是终结符节点，则可能是char, string, true, false
    // 先处理true, false，剩下的就是char, string
    if (_is_term_node(node))
    {
        if (node->data.symbol == "true")
        {
            // true
            auto instr = make_const_bool(true);
            return ret_info_t().setValue(instr);
        }
        else if (node->data.symbol == "false")
        {
            // false
            auto instr = make_const_bool(false);
            return ret_info_t().setValue(instr);
        }
        else if (node->data.symbol[0] == '\'')
        {
            // char
            auto instr = make_const_char(node->data.symbol[1]);
            return ret_info_t().setValue(instr);
        }
        else if (node->data.symbol[0] == '\"')
        {
            // string
            auto instr = make_const_str(node->data.symbol.substr(1, node->data.symbol.size() - 2));
            return ret_info_t().setValue(instr);
        }
        else
        {
            // error
            error << "unknown literal" << std::endl;
            exit(1);
        }
    }
    // 如果node自身是非终结符节点，则可能是int, real
    else
    {
        if (node->data.symbol == "IntLiteral")
        {
            // int
            auto instr = make_const_int(std::stoi(node->firstChild()->data.symbol));
            return VisitorRetInfo().setValue(instr);
        }
        else if (node->data.symbol == "RealLiteral")
        {
            // real
            auto instr = make_const_real(std::stod(node->firstChild()->data.symbol));
            return VisitorRetInfo().setValue(instr);
        }
        else
        {
            // error
            error << "unknown literal" << std::endl;
            exit(1);
        }
    }
}
```

变量的声明和赋值：

```C++
// VarDef -> ident : Type [ InitVal ]
ret_info_t RSCVisitor::visitVarDef(pst_node_ptr_t node, bool global)
{
    debug(0) << "RSCVisitor: visiting var def..." << std::endl;
    assert(
        node->data.symbol == "VarDef",
        format("Expected node VarDef, but got $ instead.", node->data.symbol));
    ret_info_t retInfo;
    // 获取ident和Type
    // 暂时不考虑数组，因此剩余子节点暂时不处理
    std::string identStr = node->getChildAt(0)->data.symbol;
    std::string typeStr = node->getChildAt(1)->firstChild()->data.symbol;

    type_ptr_t type = make_prime_type(PrimitiveType::str2type(typeStr));
    user_ptr_t value = nullptr;

    pst_node_ptr_t initValNode = node->getChildAt(3);
    user_ptr_t initVal = nullptr;
    if (initValNode->hasChild())
    {
        ret_info_t initValInfo = visitInitVal(initValNode->firstChild());
        initVal = initValInfo.getValue();
        retInfo.appendInstrList(initValInfo.instrList);
    }

    if (global)
    {
        assert(
            initVal != nullptr,
            format("global variable $ must be initialized", identStr));
        const_val_ptr_t init = cast_const(initVal);
        value = context.symbolTable.registerGlobal(identStr, type, init);
    }
    else
    {
        value = context.symbolTable.registerAlloca(identStr, type);
        if (initVal != nullptr)
        {
            store_ptr_t storeInstr = make_store(initVal, cast_alloca(value));
            retInfo.addInstr(storeInstr);
        }
    }

    retInfo.setValue(value);

    return retInfo;
}
```

## 3 测试样例

我自己仿照C定义了一个精简的RSC语言，其词法定义如下：

```
#meta PATTERN ${ $}
#meta IGNORED ${ $}

PATTERN ${
    BLANK       \s+
    LIN_CMT     //[^\r\n]*
    BLK_CMT     /\*([^\*]|\*[^/])*\*/
    IDENTIFIER  [\a_][\w]*
    STRING      "[^"]*"
    CHAR        '[^']'
    REAL        (\-|\+|\e)[\d]+\.[\d]+(\e|e(\-|\+|\e)[\d]+)
    REAL        (\-|\+|\e)0[bB][01]+\.[01]+(e(\-|\+|\e)[\d]+)?
    REAL        (\-|\+|\e)0[oO][0-7]+\.[0-7]+(e(\-|\+|\e)[\d]+)?
    REAL        (\-|\+|\e)0[xX]([\da-fA-F]+|[\d]+)\.([\da-fA-F]+|[\d]+)(e(\-|\+|\e)[\d]+)?
    INTEGER     (\-|\+|\e)[\d]+(e(\-|\+|\e)[\d]+)?
    INTEGER     (\-|\+|\e)0[bB][01]+(e(\-|\+|\e)[\d]+)?
    INTEGER     (\-|\+|\e)0[oO][0-7]+(e(\-|\+|\e)[\d]+)?
    INTEGER     (\-|\+|\e)0[xX]([\da-fA-F]+|[\d]+)(e(\-|\+|\e)[\d]+)?
    SEPARATOR   [\+\-\*\\\(\){}\[\]<>;,.\|&!=:]
    SEPARATOR   >=|<=|!=|==|\|\||&&
$}

IGNORED ${
    BLANK
    LIN_CMT
    BLK_CMT
$}
```

其文法定义如下：

```
/**
* Extended Syntax Definition for the Reduced Language for Satori Compiler
* (c) 2023 Satori Compiler Project, Beijing Jiaotong University
*/

#meta GRAMMAR ${ $}
#meta MAPPING ${ $}
#meta SEMANTIC :

GRAMMAR ${
    Program*    ::=     { VarDeclStmt | FuncDeclStmt | FuncDef }                            : SemProgram
                    ;
    VarDeclStmt ::=     VarDecl `;`                                                         : SemVarDeclStmt
                    ;
    VarDecl     ::=     `var` VarDef { `,` VarDef }                                         : SemVarDecl
                    ;
    VarType     ::=     `int` | `real` | `bool` | `char` | `str`                            : SemVarType
                    ;
    VarDef      ::=     $Ident `:` VarType { `[` $Integer `]` } [ `=` InitVal ]             : SemVarDef
                    ;
    InitVal     ::=     Expr | `{` [ InitVal { `,` InitVal } ] `}`                          : SemInitVal
                    ;
    FuncDeclStmt::=     `decl` FuncDecl `;`                                                 : SemFuncDeclStmt
                    ;
    FuncDecl    ::=     `func` $Ident `(` [ ParamList ] `)` [ `:` VarType ]                 : SemFuncDecl
                    ;
    FuncDef     ::=     FuncDecl Block                                                      : SemFuncDef
                    ;
    FuncCall    ::=     $Ident `(` [ ArgList ] `)`                                          : SemFuncCall
                    ;
    ArgList     ::=     Expr { `,` Expr }                                                   : SemArgList
                    ;
    ParamList   ::=     Param { `,` Param }                                                 : SemParamList
                    ;
    Param       ::=     $Ident `:` VarType { `[` $Integer `]` }                             : SemParam
                    ;
    Stmt        ::=     Assignment `;`                                                      : SemAssignmentStmt
                    |   VarDeclStmt                                                         : SemVarDeclStmt
                    |   `if` `(` BoolExpr `)` Stmt [ `else` Stmt ]                          : SemIfStmt
                    |   `while` `(` BoolExpr `)` Stmt                                       : SemWhileStmt
                    |   `for` `(` [ VarDecl | Assignment ] `;` [ BoolExpr ] `;` [ Assignment ] `)` Stmt   : SemForStmt
                    |   `break` `;`                                                         : SemBreakStmt
                    |   `continue` `;`                                                      : SemContinueStmt
                    |   `print` Expr `;`                                                    : SemPrintStmt
                    |   `return` [ Expr ] `;`                                               : SemReturnStmt
                    |   [ Expr ] `;`                                                        : SemExprStmt
                    |   Block                                                               : SemBlockStmt
                    ;
    Assignment  ::=     LVal `=` Expr                                                       : SemAssignment
                    ;
    Block       ::=     `{` { Stmt } `}`                                                    : SemBlock
                    ;
    UnaryExpr   ::=     ( `+` | `-` | `!` ) UnaryExpr                                       : SemUnaryExpr
                    |   Factor                                                              : SemFactor
                    ;
    MulExpr     ::=     MulExpr ( `*` | `/` | `%` ) UnaryExpr                               : SemMulExpr
                    |   UnaryExpr                                                           : SemUnaryExpr
                    ;
    Expr        ::=     Expr ( `+` | `-` ) MulExpr                                          : SemExpr
                    |   MulExpr                                                             : SemMulExpr
                    ;
    RelExpr     ::=     Expr ( `<` | `<=` | `>` | `>=` | `==` | `!=` ) Expr                 : SemRelExpr
                    |   Expr                                                                : SemExpr
                    ;
    AndExpr     ::=     AndExpr `&&` RelExpr                                                : SemAndExpr
                    |   RelExpr                                                             : SemRelExpr
                    ;
    OrExpr      ::=     OrExpr `||` AndExpr                                                 : SemOrExpr
                    |   AndExpr                                                             : SemAndExpr
                    ;
    BoolExpr    ::=     OrExpr                                                              : SemBoolExpr
                    ;
    Factor      ::=     LVal                                                                : SemLVal
                    |   FuncCall                                                            : SemFuncCall
                    |   `(` Expr `)`                                                        : SemExpr
                    |   IntLiteral                                                          : SemInt
                    |   RealLiteral                                                         : SemReal
                    |   $String                                                             : SemString
                    |   $Char                                                               : SemChar
                    |   `true`                                                              : SemTrue
                    |   `false`                                                             : SemFalse
                    ;
    IntLiteral  ::=     $Integer                                                            : SemInt
                    ;
    RealLiteral ::=     $Real                                                               : SemReal
                    ;
    LVal        ::=     $Ident { `[` Expr `]` }                                             : SemLVal
                    ;
$}

MAPPING ${
    $Ident     -->     @IDENTIFIER ;
    $Integer   -->     @INTEGER ;
    $Real      -->     @REAL ;
    $String    -->     @STRING ;
    $Char      -->     @CHAR ;
$}
```

需要程序翻译的源文件内容是：

```
/**
 * block comment 1
*/

decl func add(x : int, y : int) : int;
decl func add2(x : int, y : int, z : real, s : str) : int;
func sub() { return; }

var x : int = 10;                // integer variable
var y : bool = true;             // integer variable in scientific notation


func main() : int
{
    var a : int = 10, b : int = 1, c : bool = false;
    var d : int = +3;                    // integer variable in scientific notation
    var e : int = -3;                    // integer variable in hexadecimal notation
    var o : real = 3.14;                 // float variable
    var p : real = -2.71828;             // double variable
    var q : real = 1.0;                  // double variable in scientific notation

    var result : int = a + 2 * (d - e);

    if (d > e && a < b || -b == add(a, d) || 1)
    {
        d = 2;
    }

    /*
    block comment 2
    */

    for (var i : int = 0; i < 10; i = i + 1)
    {
        var flag : bool = true;
        while (flag)
        {
            var x : int = 1;
            if (b[i] == 0)
            {
                flag = false;
                var m : int = 0;
            }
            if (b[i] == 1)
            {
                var n : int = 1;
                continue;
            }
            else
            {
                b[i] = x - 1;
                break;
            }
        }
    }

    // line comment

    return 0;
}

func add(x : int, y : int) : int
{
    return x + y;
}
```

文法解析过程：

![image-20230628013812772](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628013812772.png)

文法其他内容（包含语义动作标记）：

![image-20230628013838607](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628013838607.png)

程序自动计算First集等内容：

![image-20230628013856914](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628013856914.png)

程序计算LR项目集：

![image-20230628013921409](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628013921409.png)

程序自动计算项目集规范族（总计152个，太多了不都展示了）：

![image-20230628013941890](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628013941890.png)

程序自动计算SLR1分析表。由于整张表**过分地大**，根本无法完全打印出来，这里只展示一小部分：

![image-20230628014120664](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628014120664.png)

SLR1分析过程：

![image-20230628014157144](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628014157144.png)

程序构造的具象语法树CST：

![image-20230628014216539](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628014216539.png)

程序构造的精简语法树RST：

![image-20230628014244823](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628014244823.png)

程序构造的抽象语法树AST：

![image-20230628014302008](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628014302008.png)

程序开始遍历AST：

![image-20230628014321299](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628014321299.png)

程序翻译得到的LLVMIR全文：

```
@x.1 = global i32 10
@y.1 = global i1 true

define void @sub() {
entry.1:

body.1:
    ret void

}

define i32 @main() {
entry.2:
    %q = alloca float
    %a = alloca i32
    %b = alloca i32
    %c = alloca i1
    %d = alloca i32
    %e = alloca i32
    %o = alloca float
    %p = alloca float
    %result = alloca i32

body.2:
    store i32 10, i32* %a
    store i32 1, i32* %b
    store i1 false, i1* %c
    store i32 3, i32* %d
    store i32 -3, i32* %e
    store float 3.14, float* %o
    store float -2.72, float* %p
    store float 1.00, float* %q
    %sub.1 = ssub i32 %d, %e
    %mul.1 = smul i32 2, %sub.1
    %add.1 = sadd i32 %a, %mul.1
    store i32 %add.1, i32* %result
if.cond.1:
expr.rel.1:
    %cmp.1 = scmp gt i32 %d, %e
    br i1 %cmp.1, label and.rhs.1, label or.rhs.1

and.rhs.1:
expr.rel.2:
    %cmp.2 = scmp lt i32 %a, %b
    br i1 %cmp.2, label if.then.1, label or.rhs.1


or.rhs.1:
expr.rel.3:
    %neg.1 = sneg %b
    %call.1 = call i32 @add(%a, %d)
    %cmp.3 = scmp eq i32 %neg.1, %call.1
    br i1 %cmp.3, label if.then.1, label or.rhs.2


or.rhs.2:
expr.rel.4:
    %cmp.4 = scmp ne i32 1, 0
    br i1 %cmp.4, label if.then.1, label fall.1



if.then.1:
    store i32 2, i32* %d

fall.1:
for.init.1:
    %i = alloca i32
    %flag = alloca i1
    store i32 0, i32* %i

for.cond.1:
expr.rel.5:
    %cmp.5 = scmp lt i32 %i, 10
    br i1 %cmp.5, label for.body.1, label fall.2


for.body.1:
    store i1 true, i1* %flag
while.cond.1:
expr.rel.6:
    %cmp.6 = ucmp ne i1 %flag, false
    br i1 %cmp.6, label while.body.1, label fall.3


while.body.1:
    %x = alloca i32
    store i32 1, i32* %x
if.cond.2:
expr.rel.7:
    %cmp.7 = scmp eq i32 %b, 0
    br i1 %cmp.7, label if.then.2, label fall.4


if.then.2:
    %m = alloca i32
    store i1 false, i1* %flag
    store i32 0, i32* %m

fall.4:
if.cond.3:
expr.rel.8:
    %cmp.8 = scmp eq i32 %b, 1
    br i1 %cmp.8, label if.then.3, label if.else.1


if.then.3:
    %n = alloca i32
    store i32 1, i32* %n
    br label while.cond.1

if.else.1:
    %sub.2 = ssub i32 %x, 1
    store i32 %sub.2, i32* %b
    br label fall.3


    br label while.cond.1
fall.3:

for.last.1:
    %add.2 = sadd i32 %i, 1
    store i32 %add.2, i32* %i
    br label for.cond.1

fall.2:
    ret i32 0

}

define i32 @add(i32 %x, i32 %y) {
entry.3:
    %x = alloca i32
    %y = alloca i32

body.3:
    %add.3 = sadd i32 %x, %y
    ret i32 %add.3

}
```

## 4 实验总结

本次实验我完成了编译器前端。并且我的程序是自动生成词法分析器和语法分析器的，且其将源程序直接翻译的LLVMIR，相比普通的四元式更符合工业规范，具有更高的使用价值。感谢老师的悉心教导。