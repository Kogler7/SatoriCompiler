# 开悟编译器项目简要总结说明

[TOC]

## 1 写在前面

### 1.1 立项缘由

这个编译器的名字是`SatoriCompiler`。

`Satori`，意为**开悟、顿悟**。我为自己的编译器赋予此名，是期望自己能在动手实践的过程中不断地收获在**知识技能上的顿悟**，以及在**人生方向上的开悟**。`Satori`其实是一个**系列**，是我**大学实践探索的轨迹**。类似的，我还写了`SatoriOS`（基于龙芯的微型**操作系统**）和`SatoriBlog`（Vue+Spring+MySQL）的个人论坛**博客系统**。

在大学学习的方向上，我推崇**实践导向**和**问题导向**，认为**只有在不断实践中才能发现有价值的问题，只有在解决问题的过程中才能真正地学到知识和技能**。同时，我坚信，**量变才能产生质变**，只有一定的代码量的积累，才能真正培养出**利用计算机解决实际问题**的能力。编译器作为公认的编程届**三大浪漫**（分别是操作系统、编译器和计算机图形学）之一，又作为专业课程中的**核心一环**，必然蕴含了大量值得学习研究的思想和方法。因此，我认为自己动手实现一个小型的编译器非常有意义，这也必将是我求知道路上具有**里程碑意义**的一件大事。

### 1.2 项目定位

我要做的是一个**独立**的、**有效**的编译器，既不简单，也不复杂。

不简单，是指**所有代码均自主编写**，不依赖除STL以外的库和工具。在这个项目中，我常用的**格式化日志输出工具、自动表格排版工具、元信息解析工具和输入流浏览工具**均是我手动编写的。同时我要求这个编译器必须有足够的**抽象性**和**鲁棒性**。所谓抽象性，即是编译器要能提供尽可能高的抽象，允许用户自定义词法、语法乃至语义，编译器要能根据用户给出的**正则表达式**定义的词法自动生成基于NFA的词法分析器，要能根据**EBNF**定义的文法自动生成语法分析器（也就是老师说的**自动造表**），编译器要将语法分析得到的**CST**转化为简洁清晰的**AST**，以便对语义分析部分隐去不必要的细节，编译器要生成基于**LLVM IR**的中间表示（可以理解为三地址码的升级版），这样便可借助LLVM工具链来验证编译器前端生成结果的正确性，也可以利用LLVM后端实现代码优化，使得编译器真正具有**实用价值**。

不复杂，指的是要**综合投入成本和时间效率**的考虑，将实现重心放在编译器的**前端**，同时完成老师布置的实践作业。由于时间原因，编译器很难做到良好的**错误提示**和**代码优化**，这部分工作可以放到暑假参与编译竞赛的过程中去做。

### 1.3 开发环境

项目使用`C++20`标准（低于此标准可能导致编译错误），基于`MSVC（Microsoft Visual C++）`编译器（如果使用GCC编译可能出现不兼容问题）。项目使用`CMake`工具辅助工程构建。项目开发使用`Visual Studio Code`和`Visual Studio 2022`，其中`VSCode`是开发主力，`VS 2022`则主要在测试调试时使用。项目接受文件输入，产生命令行输出。

## 2 项目架构

### 2.1 元信息的定义和解析器实现

在我的项目中，一切**配置文件**都遵循**元信息**的格式。我定义的元信息的基础格式如下：

```
#meta PATTERN ${ $}
#meta IGNORED ${ $}

PATTERN ${
    BLANK       \s+
    LIN_CMT     //[^\r\n]*
    BLK_CMT     /\*([^\*]|\*[^/])*\*/
    IDENTIFIER  [\a_][\w]*
    SEPARATOR   [\+\-\*\\\(\)\[\]/,;=]
$}

IGNORED ${
    BLANK
    LIN_CMT
    BLK_CMT
$}
```

这是一个**词法**定义文件，文件中定义了两个元信息`#meta PATTERN`和`#meta IGNORED`，并将信息的内容通过其后定义的**起止符**包裹起来。这样的文件可以被我实现的`MetaParser`解析，从而作为后序程序的配置输入。

元信息的功用远不止于此。事实上，我为`MetaParser`添加了**递归下降**的实现方式，这使得元信息之中还可以**嵌套元信息**。同时，元信息不但支持含有起止符标记的**块信息**的解析，还支持由引导符标记的**行信息**的解析。一个典型的应用实例如下：

```
/**
* Extended Syntax Definition for the Reduced Language for Satori Compiler
* (c) 2023 Satori Compiler Project, Beijing Jiaotong University
*/

#meta GRAMMAR ${ $}
#meta MAPPING ${ $}
#meta SEMANTIC :

GRAMMAR ${
    Program*    ::=     { VarDeclStmt | FuncDeclStmt | FuncDef }   : SemProgram
                    ;
    VarDeclStmt ::=     VarDecl `;`                                : SemVarDeclStmt
                    ;
                    ......
$}
......
```

上面是从**RSC**（我计划实现的语言的名称）**文法**定义中截取的一部分，可以看到，我利用**嵌套的行信息**在EBNF中为对应的产生式添加了**语义动作**的注解。

在我的项目中，**几乎所有**需要配置的地方都接受元信息的输入，一个典型的例子如下：

```C++
/**
 * @brief Syntax Parser的构造函数，主要完成用到的词法分析器的初始化
 *
 * @param ebnfLexPath EBNF词法分析器的元数据文件路径
 */
SyntaxParser::SyntaxParser(const string ebnfLexPath)
{
    MetaParser lexMeta = MetaParser::fromFile(ebnfLexPath);
    ebnfLexer = Lexer(lexMeta["EBNF"], lexMeta["IGNORED"]);
    mappingLexer = Lexer(lexMeta["MAPPING"], lexMeta["IGNORED"]);
    precLexer = Lexer(lexMeta["PREC"], lexMeta["IGNORED"]);
}
```

元信息解析器并不是我一开始就设计实现的，而是在不断迭代完善整个编译器的过程中才出现的需求。相关的实现细节请参考源码`src/utils/meta`，在此不再赘述。

### 2.2 基于正则引擎的词法分析器

此节已在**第一次实验报告**中详细讨论过，这里只挑一些重点阐述。

#### 2.2.1 词法规则的定义

定义词法有多种方式，课上老师主要讲的是**正则文法**。我**采用的是正则表达式**，这主要是受到现代比较成熟的**词法/文法分析器生成器**的做法的启发，有其工程实践上的优势和意义。针对这样的设计，我实现了一个**正则表达式解析引擎**和**NFA构造器**，同时根据文法定义完成了词法分析结果到相应关键字、终结符的**映射**。这样做有许多好处，下面将进行讨论。

正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

一般来讲，正则表达式支持如下特性：

> 1. 字符组：用方括号 [] 来表示，可以匹配方括号中的任意一个字符。例如 [abc] 可以匹配字符 a、b 或 c。
> 2. 数量词：用来指定匹配的次数，例如 * 表示匹配 0 次或多次，+ 表示匹配 1 次或多次，? 表示匹配 0 次或 1 次，{n} 表示匹配 n 次，{n,m} 表示匹配 n 到 m 次。
> 3. 特殊字符：包括元字符、转义字符和定位符。元字符包括 .、|、() 等，用来表示特定的字符或字符集合。转义字符用来表示特殊字符，例如 \d 表示匹配数字，\s 表示匹配空白字符。定位符用来匹配字符串的位置，例如 ^ 表示匹配字符串的开头，$ 表示匹配字符串的结尾。
> 4. 分组：用圆括号 () 来表示，可以将多个字符组合成一个整体，方便进行匹配和替换。例如 (ab)+ 表示匹配一个或多个连续的 ab。
> 5. 前后查找：用来匹配某个字符前面或后面的字符。例如 (?<=a)b 表示匹配前面是 a 的 b，(?=a)b 表示匹配后面是 a 的 b。
> 6. 贪婪匹配和非贪婪匹配：默认情况下，正则表达式会尽可能地匹配更多的字符，这种匹配方式称为贪婪匹配。如果在量词后面加上 ?，则表示非贪婪匹配，即尽可能少地匹配字符。

我实现的**简易的正则表达式的解析引擎**，其所支持的功能是标准正则表达式功能的**子集**，具体功能约定如下（命名并不规范，仅作理解用）：

1. **字符组、字符区间、反选字符**：用方括号 `[]`表示字符组，匹配方括号中的**任意**一个字符。形如 `a-z`、`0-9`的字符子串表达一个字符**区间**。左方括号后紧跟一个 `^`表达对字符组所确定的字符进行**反选**，即有效字符的**全集**减去字符组内的字符得到的新字符组。
2. **转义字符、等价字符、通配符**：以转义字符 `\`开头的字符将会被转义，例如操作符 `+`被转移后就失去了操作符的含义，可用于表达对加号的匹配。特别的，`\e`等价于符号$\epsilon$，`\d`等价于 `0-9`，`\a`等价于 `a-zA-Z`，`\w`等价于 `a-zA-Z0-9_`，`\s`代表所有的空白字符，等等。`.`代表通配符，即接受有效字符的全集。
3. **单目操作符**：我实现的简易的正则表达式支持四种基本的单目操作符（均只接受**左目参数**）。`^`代表连接符（省略不写，分析程序会自动加上，无需转义）；`?`代表可选符，其之前的字符可以出现一次或零次；`+`代表正闭包，其之前的字符应至少出现一次；`*`代表闭包符，其之前的字符可以出现零次、一次或多次。
4. **双目操作符**：目前仅支持一种双目操作符 `|`，表示该操作符两边的内容是或的关系，该操作符相比上述操作符的**优先级最低**。
5. **分组**：支持使用 `()`提升圈中部分的字符的处理优先级，被圈中的字符集会被视为一个整体参与后续的计算。

正则表达式涉及到对ASCII字符串的解析，首先可以将ASCII字符大致分为两类，一类是供正则表达式引擎识别的**普通字符**，另一类则是表达正则表达式语义的**特殊字符**。其中，特殊字符主要包含**运算符**和**转义字符**。

#### 2.2.2 正则表达式的处理

我设计的正则表达式解析过程主要分为**三个阶段**。

**第一步，我的正则引擎首先会对正则表达式做预处理**。

这么做的最核心的原因是，将正则表达式转化为**整齐**的**中缀表达式**。所谓整齐，我给的定义就是指表达式中的所有**表达特定语义的单元**都必须是**单个字符**，以方便后续的解析处理。举例而言，正则表达式中范围选择语义`[0-9]`是多个字符，经过预处理后会变成一个不可见的单字符，这里用`SET`表示（预处理器会将诸如 `[0-9a-z_]`的语法先行解析，并预先存储到 `setStates`中备用）。类似的，`\e`要被处理为`EPSILON`，`\+`要被处理为`+`（因为不经转义的`+`会被识别为运算符）。

此外，为了方便后续处理，预处理器会根据字符的结合性在字符之间添加**连接符**`CONCAT`。

例如，对于正则表达式：

```reStructuredText
(\-|\+|\e)[0-9]+
```

预处理器会将其转换为：

`PARENT_L`-`SELECT`+`SELECT` `EPSILON` `PARENT_R` `CONCAT` `SET` `PLUS`

**第二步，我的正则引擎会将中缀表达式转为后缀表达式**。

这么做是因为逆波兰式更便于机器分析计算（使用**栈**即可）。

例如，对于正则表达式：

```
>=|<=|!=|==|\+\+|\-\-|\|\||&&|\*=|/=|\+=|\-=|%=|<<|>>
```

经过**预处理**得到：

.>`CONCAT`=`SELECT`<`CONCAT`=`SELECT`!`CONCAT`=`SELECT`=`CONCAT`=`SELECT`+`CONCAT`+`SELECT`-`CONCAT`-`SELECT`|`CONCAT`|`SELECT`&`CONCAT`&`SELECT`*`CONCAT`=`SELECT`/`CONCAT`=`SELECT`+`CONCAT`=`SELECT`-`CONCAT`=`SELECT`%`CONCAT`=`SELECT`<`CONCAT`<`SELECT`>`CONCAT`>

进一步转化为**后缀表达式**得到：

\>=`CONCAT`<=`CONCAT` `SELECT`!=`CONCAT` `SELECT`==`CONCAT` `SELECT`++`CONCAT` `SELECT`--`CONCAT` `SELECT`||`CONCAT` `SELECT`&&`CONCAT` `SELECT`*=`CONCAT` `SELECT`/=`CONCAT` `SELECT`+=`CONCAT` `SELECT`-=`CONCAT` `SELECT`%=`CONCAT` `SELECT`<<`CONCAT` `SELECT`>>`CONCAT` `SELECT`

**第三步，利用汤普森方法根据后缀表达式构造NFA**。

汤普森构造法是一种将正则表达式转换为NFA的方法。其基本思想是，将正则表达式中的每个字符或操作符转换为一个NFA，并通过连接和或操作符将它们组合起来。

具体步骤如下：

 1、对于正则表达式中的每个字符，构造一个只有两个状态的NFA。该NFA有一个转移边，标记为该字符。
 2、对于正则表达式中的连接（`CONCAT`）操作符，将前一个NFA的终止状态连接到后一个NFA的起始状态。
 3、对于正则表达式中的或操作符（`SELECT`），构造一个新的起始状态和一个新的终止状态，并将前一个NFA和后一个NFA分别连接到这两个状态。
 4、对于正则表达式中的闭包（`STAR`）操作符，构造一个新的起始状态和一个新的终止状态，并将原来的NFA连接到这两个状态。然后，将新的起始状态连接到原来的起始状态和新的终止状态，将原来的终止状态连接到原来的起始状态和新的终止状态。
 5、最终的NFA的起始状态为正则表达式的起始状态，终止状态为正则表达式的终止状态。

 <center>
 	<img src="https://img-blog.csdnimg.cn/img_convert/c19e51dab02f142d16b1210ce713575f.png" width="15%"></img>
 	<img src="https://img-blog.csdnimg.cn/img_convert/3bf9d5f046ce7566697d833f14fd1bd0.png" width="20%"></img>
 	<img src="https://img-blog.csdnimg.cn/img_convert/92d5f471bf9a9bfa86fc5e613848949d.png" width="20%"></img>
 	<img src="https://img-blog.csdnimg.cn/img_convert/1f371a8ed4399a9f7a69daa6ad4a0f32.png" width="25%"></img>
 </center>


类似的还可以实现`PLUS`、`QUES`等操作符，不再赘述。

通过以上步骤，我们就可以将正则表达式转换为一个NFA。

#### 2.2.3 词法分析器的简单实现

实现词法分析器有两个重要步骤。

**第一，是在上一步生成的NFA的基础上，实现针对单条规则NFA的`accepts`方法**，负责检测传入的字符串是否能被该NFA接受，并返回接受的单词内容。在我的设计实现中，该函数主要采取**递归调用**的方式，每次递归向前接受一个字符，并将接受的字符拼接到返回的结果中，若无法接受则回溯至可以接受的状态，直至找到**最长的匹配前缀**或者匹配失败。

**第二，将多条词法规则对应的NFA组合成一个词法分析器，实现`tokenize`方法**，由词法分析器决定选用哪个NFA来处理当前的字符输入流，并得到最终的词素序列。在这里，我的实现方法比较简单粗暴，核心思路就是针对当前输入流**依次（有先后顺序）**使用不同规则定义的NFA尝试匹配，并取**第一个的最长匹配结果**作为接受的`Token`。当然，针对标记为`IGNORED`类型的token，词法分析器会直接将其丢弃。

受篇幅约束，相关实现细节请查阅第一次实验报告或源码。

### 2.3 递归下降的EBNF文法解析器

在我的定义中，**文法解析器**不是**语法分析器**。语法分析器是指根据某一文法去分析输入的词素序列是否满足文法要求。这里的文法是抽象的概念。在工程实践中，需要将**文法**定义为某种**数据结构**，并将通过某种方式定义的**描述文法的文件**解析成相应的文法数据。完成这项工作的，就是本节要讨论的文法解析器。

#### 2.3.1 元信息的配置与词法解析

在 2.1 节已经指出，文法解析器接受元信息作为输入，并依次完成内部词法分析器的配置。想必您遇到的第一个疑问便是，为什么文法解析器中会有词法分析器？请参见下面关于文法解析器的类型声明：

```C++
class SyntaxParser
{
    MetaParser syntaxMeta;                // 元信息解析器
    Lexer ebnfLexer;                      // EBNF词法解析器
    Lexer mappingLexer;                   // 映射词法解析器
    Lexer precLexer;                      // 优先级词法解析器
    Grammar grammar;                      // 语法解析结果
    std::map<symbol_t, int> nonTermCount; // 非终结符计数器，用于程序自动生成唯一的新非终结符

    std::vector<tok_product_t> tokProducts; // 用于存储解析出的词素产生式
    std::vector<tok_product_t> segmentProduct(tok_product_t &product);
    void parseNonTrivialProducts(std::vector<tok_product_t> &tmp, const symbol_t &left, token_const_iter_t beginIt, token_const_iter_t endIt);

    void addSyntaxRules(const std::vector<token> &tokens);
    void addTokenMappings(const std::vector<token> &tokens);
    void addPrecAndAssoc();

public:
    SyntaxParser(const std::string syntaxLexPath);
    Grammar parse(const std::string grammarPath);
};
```

在我的项目中，文法由**EBNF**（Extended Backus-Naur Form，即扩展巴克斯-诺尔范式）定义，该范式在BNF范式的基础上，定义了几个方便的运算符，用以表达**分组、可选、重复**等语义。为了解析EBNF，我首先利用词法分析器将其转化为词素序列，以便后续分析。

针对于EBNF解析的词法分析的词法定义如下。其他类似。

```
EBNF ${
    BLANK       \s+
    EPSILON     \\e
    START_MRK   \*
    SEMANTIC    SEMANTIC
    TERMINAL    `[^`]*`
    NON_TERM    [\a_][\w']*
    MUL_TERM    $[\a_][\w']*
    TOK_TYPE    @[\a_][\w']*
    DELIMITER   [\(\){}\[\]\|]
    SEPARATOR   ;
    GRAMMAR_DEF ::=
    COMMENT     //[^\r\n]*
    COMMENT     /\*([^\*]|\*[^/])*\*/
$}
```

事实上，我的文法解析器的真正的输入是**词素序列**，包括**EBNF的词素序列、终结符映射定义的词素序列、优先级和结合性关系定义的词素序列**等等，他们分别遵循不同的词法，因此需要为文法解析器配备多个词法分析器。

关于终结符映射和优先级结合性的讨论，请参考 2.4.3 小节。

关于这部分的详细实现，请查阅源码。

#### 2.3.2 文法产生式定义的预处理

文法解析器首先会根据EBNF词素流提取出初步的产生式信息。在这个过程中得到的产生式并不是最终文法的产生式，而是包含**EBNF运算符**的**词素产生式**。

上面一段话包含两个信息。

**其一，预处理得到的词素产生式中包含EBNF运算符**。我定义的EBNF运算符有四种，分别是**`|`选择符、`()`分组符、`[]`可选符和`{}`重复符**。选择符分开的部分将分别变成单独的产生式加入到最终的文法中，分组符可以针对每个选择部分附加组外的其他部分，可选符意味着其中的部分可有可无，重复符意味着其中的部分会重复出现零次或多次。这些运算符在预处理阶段会被保留，等留到后续阶段再完成递归下降的解析处理。

下面是关于四种运算符的样例（摘自我自己设计的RSC文法）：

```ebnf
Program*    ::=     { VarDeclStmt | FuncDeclStmt | FuncDef }
VarType     ::=     `int` | `real` | `bool` | `char` | `str`
ParamList   ::=     Param { `,` Param }
UnaryExpr   ::=     ( `+` | `-` | `!` ) UnaryExpr
Stmt        ::=     `if` `(` BoolExpr `)` Stmt [ `else` Stmt ]
```

**其二，预处理得到的产生式中包含词素信息**。标准的产生式只包含终结符和非终结符，也就是源码中的`symbol`，而预处理器在这个阶段并没有将词素序列的附加信息删除。**词素中的附加信息包括，词素的类型和词素在源码中的位置**。这些信息有助于在文法解析出错时，程序可以向用户提示文法出错的上下文信息。

预处理阶段的主要工作就是根据文法定义中的分隔符`;`来完成产生式的初步拆分，详细实现请参照源码相关部分，在此不再赘述。

#### 2.3.3 递归下降的EBNF运算符解析

在我的实现中，EBNF解析器是递归下降完成解析的。这么做的根本原因是，我希望支持EBNF运算符的**嵌套**和**组合**。下面是一些典型的例子。

EBNF运算符组合：

```
VarDef ::= $Ident `:` VarType { `[` $Integer `]` } [ `=` InitVal ]
```

EBNF运算符嵌套：

```
InitVal ::= Expr | `{` [ InitVal { `,` InitVal } ] `}`
```

运算符解析的过程大致可以分为**两步**。

**第一步**，根据选择符`|`划分产生式，若发现其他运算符则对需要处理的部分**递归执行**第二步；

**第二步**，根据不同运算符执行相应处理，若发现运算符中包含选择符，则先对需要处理的部分**递归执行**第一步。

如此往复，就实现了EBNF运算符组合与嵌套的情况的解析。

从细节上来看，针对不同EBNF运算符的处理也值得讨论。

首先是针对**分组符**的处理。

文法解析器处理分组符的过程相对比较简单。它只需要将分组符所包含的内容送入上述第一步方法中，便可以得到拆分后的**子产生式向量**，而后将每一个子产生式与产生式剩余部分进行**组合**（实际上为**全连接**操作，详细原因不再赘述）即可。其处理方式可以描述如下：

```
S -> A(B|D)C => S -> ABC, S -> ADC
```

其次是针对**可选符**的处理。

可选符的处理与分组符类似，不同之处在于，文法解析器在处理可选符时需要额外构造一个**不含可选符中内容**的产生式。

```
S -> A[B|D]C => S -> ABC, S -> ADC, S -> AC
```

最后是针对**重复符**的处理。

处理重复符的过程本质上是**创建新的非终结符**，并构建**含右递归的新产生式**的过程。**程序自动构建**的新产生式将会用于**文法分析**，并在文法分析结束后通过**重构CST将其消去（将在 2.5.4 节介绍）**，最终在用户的视角来看，这一切都是**透明**的。

```
S -> A{B|D}C => S' -> B|D, S'' -> S'S'' | ε, S -> AS''C
```

#### 2.3.4 拓展语法信息的解析处理

拓展语法信息包含**终结符映射、优先级与结合性、属性文法语义动作**等信息。至于为什么需要这些信息，请参见 下面的讨论。

2.3.2 节说到，预处理阶段得到的产生式包含词素信息。经过 2.3.3 节的处理解析，各产生式基本拆分完毕。本节要做的工作，就是将词素产生式中多余的信息删去，构建出**文法实例**，同时完成拓展语法信息的解析。

解析器会首先遍历每一个词素产生式的每一个token，按照其类别将其转化为符号`symbol`，构建文法产生式，并同时生成文法的终结符、非终结符集合。这是一个**平凡**的过程，不赘述。在这个过程中，有**三个**需要注意的特别的地方。

**第一个是终结符映射信息的解析**。

在EBNF定义经过词法分析后，会产生一种名为**映射终结符**（在程序中一般命名为`mul-term`）的词素，它隐含了一种信息，即该类终结符将在语法分析阶段对应**含有多种不同的值的词素**，一种典型的映射终结符是`ident`（意为**标识符**），他将在语法分析阶段匹配多种类型为`IDENTIFIER`但值各有不同的词素。除了`ident`，还有一些常见的映射终结符，他们在项目文法中的定义如下：

```
MAPPING ${
    $Ident     -->     @IDENTIFIER ;
    $Integer   -->     @INTEGER ;
    $Real      -->     @REAL ;
    $String    -->     @STRING ;
$}
```

在上面的定义中，箭头`-->`的左边代表文法中出现的映射终结符，右边代表词法分析器解析得到的词素类型，下面分别给出文法和词法中使用映射非终结符的例子：

```
FuncDef     ::=     Type $Ident `(` [ ParamList ] `)` Block
```

```
IDENTIFIER  [\a_][\w]*
```

不难发现，映射终结符的存在是一种**必然**，因为程序代码需要支持**用户自定义符号**和**数据字面量**，而仅凭文法终结符是**无法穷举**所有可能的字符组合的，这便是映射终结符存在的意义。

上述解析大致的实现方法是，文法解析器会将带有`mul-term`类型标记的词素转化为普通的终结符，但同时填写存储在**文法数据结构**中的一个**映射表**。通过这个映射表，我们就可以在语法分析之前，先将源码遍历得到的**词素序列**做一次**映射翻译**，再将其送入语法分析器分析，这样就实现了映射。

**第二个是优先级与结合性信息的解析**。

优先级与结合性在老师讲授的文法分析的内容中并不是重点，但其在**工程实践上**意义重大。它们一方面是各类**程序语言中不可或缺的特性**，另一方面则是**解决文法二义性问题的工具**。

除了老生常谈的**表达式中优先级与结合性规则的应用**，还有一个经典的案例是`dangling else`问题。通过实践不难发现，常见的**if else**文法具有二义性。其最主要的特点是，语法分析器不知道**将else语句划分给哪一个if语句**，同时，如果文法设计的不好，该文法在SLR分析器中还会产生**移进-规约冲突**，即语法分析器在遇到`if stmt . else stmt`时不知道该移进还是该规约。这将大大限制了文法的表达能力和SLR1语法分析器的应用。

经过调研发现，现代语法分析器生成器（Yacc等）处理二义性文法的普遍做法分两步进行：

1. 按**优先级规则**消除部分移进/规约冲突

2. 再按**确定性规则**解决余下的冲突

​		a. 对于移进-规约冲突，优先移进
​		b. 对于规约-规约冲突，选用列在文法最前面的语法规则规约

当然，我们也可以选择修改文法。但这样会造成**文法规则的分散**，并为之后的**语义规则的绑定**带来额外的困难。

针对优先级的解决方案，有如下讨论

> BYacc：如果lookahead记号和栈顶符号都有优先级，选择优先级高的，如果优先级相同，则看结合性；右结合选择移进，左结合选择规约，无结合两者皆不选。如果两者不全有优先级，则优先移进（即根据确定性规则处理移进-规约冲突）
>
> CUP：如果栈顶符号有优先级，则比较它和lookahead的优先级，大于则移进，小于则规约，等于再看结合性；左结合则规约，右结合则移进，无结合则做特殊标记。如果栈顶符号没有优先级，lookahead有优先级，则移进。如果两者皆没有优先级，则用确定性规则解决。

在我的项目中，优先级和结合性通过前述元信息的方式定义，并由文法解析器解析后填入到文法数据结构中。

**第三个是属性文法语义动作的解析**。

在我的项目中，语义信息的标记如下所示：

```
GRAMMAR ${
    Program*    ::=     { VarDeclStmt | FuncDeclStmt | FuncDef }  : SemProgram
                    ;
    VarDeclStmt ::=     VarDecl `;`                               : SemVarDeclStmt
                    ;
    VarDecl     ::=     `var` VarDef { `,` VarDef }               : SemVarDecl
                    ;
$}
```

在进行文法解析的过程中，元信息解析器会将语义信息提取出来，形成一个**语义动作的序列**。文法解析器则负责在整理文法的过程中根据产生式所在的行为每个产生式附加其对应的**语义动作标记**。关于语义标记方面，我最开始采取的方案是利用**C++宏定义**来实现语义动作的自定义，但我很快发现这样做有两个巨大的缺陷。其一是宏定义会将参数中代码块中的逗号当作参数的分隔符，导致语义动作不能被正确定义；其二是通过宏定义定义的语义动作只能全局被导入一次，否则会出现重复定义的编译错误。因此，最后我丢弃了这个方案，改为采用语义动作标记加内置相关代码的方案。

### 2.4 文法和语法分析器及其扩展

#### 2.4.1 基础文法及其继承体系的设计与实现

这一节主要对标的是**实验内容**。实验要求实现LL(1)、OPG和SLR1语法分析器，我将文法和语法分析器分别抽象出来，每一种类型的分析器都接受其相应类型的文法，这样就形成了文法之间的继承体系。首先是基础文法。

> 本节所述文法相关代码均可在源码`src/common/gram`文件夹下找到。

```C++
class Grammar
{

public:
    symbol_t symStart;
    symset_t mulTerms;
    symset_t nonTerms;
    symset_t terminals;

    product_t startProduct;
    std::vector<product_t> products;
    std::map<symbol_t, std::set<symstr_t>> rules;

    std::map<token_type_t, symbol_t> tok2sym;
    std::map<product_t, semantic_t> semMap;
    std::map<symbol_t, prec_assoc_t> precMap;
    ......
};
```

为节约篇幅，上述代码隐去了一部分方法，**仅保留了类所包含的字段**，下面代码也将如此。观察上述代码不难发现，基础文法作为其他文法的基类，记录了由文法解析器解析EBNF得到的所有信息，包括**开始符号、终结符、非终结符、映射终结符、产生式、文法规则、映射关系表、语义动作表和优先级关系表**等等。

在此基础上，我们可以得到**预测文法**。所谓预测文法，可以理解为为**LL(1)语法分析器**服务的文法数据结构。其中包含了**First集、Follow集的计算方法和结果**。其实LL(1)分析法无论是利用**递归下降**分析，还是利用**显式的栈**（递归下降本质上是利用隐式的栈）进行分析，都要用到**预测分析表**，而计算First集和Follow集就是预测分析的**关键**所在。因此，该文法便得名预测文法。

预测文法的数据结构如下（这边我其实额外求了一个**select集**，会更便于判断一个文法是否是LL1文法，更便于填写预测分析表）：

```C++
class PredictiveGrammar : public Grammar
{
	......
public:
    std::map<symbol_t, symset_t> first;
    std::map<symstr_t, symset_t> firstS;
    std::map<symbol_t, symset_t> follow;
    std::map<product_t, symset_t> select;
    ......
};
```

**LR文法**继承了预测文法。在LR系列的分析法中，需要计算项目集规范族和分析表。在一些LR分析法中，需要**利用Follow集来处理冲突**，因此LR文法中需要提供计算First集和Follow集的方法，这便是LR文法需要继承自预测文法的原因。

```C++
class LRGrammar : public PredictiveGrammar
{
    ......
public:
    clusters_t clusters;
    std::vector<lr_item_t> items;
    table_t<state_id_t, symbol_t, state_id_t> goTrans;
    ......
};
```

在LR基础文法的基础上，SLR1文法又添加了SLR1分析表，其主要数据结构如下。这非常好理解，不多做解释。

```C++
class SLR1Grammar : public LRGrammar
{
    ......
public:
    table_t<state_id_t, symbol_t, action_t> slr1Table;
    ......
};
```

除了上述继承链外，算符优先文法独树一帜。它直接继承自基础文法，其数据结构如下：

```C++
class OperatorPrecedenceGrammar : public Grammar
{
    ......
public:
    std::map<symbol_t, symset_t> firstVT;
    std::map<symbol_t, symset_t> lastVT;
    table_t<symbol_t, symbol_t, int> opt; // operator precedence table
    ......
};
```

以上便是老师课上讲的几种基础的语法分析器所需要的文法信息的实现。

#### 2.4.2 经典语法分析算法的设计与实现

本节主题几乎涵盖了**课内实验内容**的**大部分重点**，这些内容在过往的**实验报告**中均有涉及和讨论，由于篇幅限制，这里不再赘述。

#### 2.4.3 扩展语法和扩展语法分析器的实现

**扩展语法**在这里并非指编译原理中**扩展文法**的概念。在**课内内容**中，扩展文法是指为已有的文法添加一个额外的包含原起始符号和新起始符号的产生式，以确保该产生式的唯一性。但在**本项目的实践**中，扩展文法主要用于记录一些传统文法所不能表达的信息，比如**属性文法、映射终结符、终结符优先级和结合性**等。

这部分信息的核心**解析工作**已经在 **2.3.4** 节讨论，本节仅论述相关信息在语法分析过程中的**应用**。能够利用扩展语法的分析器被我称为扩展语法分析器。例如，我为RSC语言写的文法就是`rsc.estx`扩展语法，而对应的语法分析器就是`ESLR`（即扩展的SLR1分析器）。

由于时间优先，我并没有完全实现对上面的信息的利用。

关于**属性文法**信息（或者说是语义动作标记），我仅仅实现了对该类信息的解析处理。后来为了更好地**优化RSC语义的分析过程**，我直接对RSC写了针对性的**Visitor**，因此最终语义动作标记没有得到使用。（但是处理语义信息的接口已经实现了，可以在此基础上实现其他简单的语义分析，就不再赘述）

关于**映射终结符**信息（相关讨论主要在 2.3.4 节），我将该信息存储在了基础文法中，而后将解析源文件得到的词素序列先经过文法的映射翻译后再送到语法分析器中分析，这样就实现了一个终结符对应多个词素值的映射。

关于**终结符优先级和结合性**信息，本来是打算用于处理SLR1分析过程中的**移进规约冲突**（对于复杂的文法这点很容易出现）和优化文法表达的。由于时间原因，我在实现了对该信息的解析之后并没有将其应用到语法分析的过程，而是直接采用了**优先移进**的原则（这点在 2.3.4 节有讨论）解决了冲突。

除了上述几个关键区别外，我解析RSC使用的扩展语法分析器还针对性地做了其他优化，由于篇幅限制，不多赘述。

### 2.5 三种解析语法树的构造转换

事实上，针对简单的文法，我们可以通过附加语义动作的产生式在语法分析的同时完成翻译。但对于复杂的文法，这样做的好处就几乎为零了。在计算机领域，尤其是涉及到编程问题的地方，有一个非常好用的**哲学**。那便是通过**添加抽象的层数**来一步步将问题**简化**，我们只需要**保证每一层和其他层之间转换的正确性**，就能**保证整个复杂的处理过程的正确性**。在这里，为了实现对RSC语言的翻译，我设计了**三种解析语法树及其互相的转换过程**。

#### 2.5.1 语法解析树PST抽象类的设计与实现

在整个项目中，有许多用得到树这一数据结构的地方。为此，我专门实现了一个抽象的树结构，支持**树节点数据的挂载、子节点的查询、子节点顺序反转、子节点访问、子节点插入、节点信息描述、子节点遍历、树的前序遍历、树的后序遍历、树的形状打印**等功能，其主要实现如下：

```C++
template <typename data_t>
class AbstractTreeNode;

template <typename data_t>
using tree_node_t = AbstractTreeNode<data_t>;

template <typename data_t>
using tree_node_ptr_t = std::shared_ptr<AbstractTreeNode<data_t>>;

template <typename data_t>
using tree_children_t = std::vector<tree_node_ptr_t<data_t>>;

template <typename data_t>
class AbstractTreeNode : public tree_children_t<data_t>
{
public:
    tree_node_t<data_t> *parent;
    data_t data;

    AbstractTreeNode(data_t data) : data(data), parent(nullptr) {}

    static tree_node_ptr_t<data_t> createNode(data_t data)
    {
        return std::make_shared<tree_node_t<data_t>>(data);
    }

    size_t find(data_t data) const
    {
        auto it = find_if(
            tree_children_t<data_t>::begin(), tree_children_t<data_t>::end(),
            [=](tree_node_ptr_t<data_t> node)
            { return node->data == data; });
        return it == tree_children_t<data_t>::end() ? -1 : it - tree_children_t<data_t>::begin();
    }

    template <typename func_t>
    size_t find(func_t cmp) const
    {
        auto it = find_if(tree_children_t<data_t>::begin(), tree_children_t<data_t>::end(), cmp);
        return it == tree_children_t<data_t>::end() ? -1 : it - tree_children_t<data_t>::begin();
    }

    void reverseChildren()
    {
        reverse(tree_children_t<data_t>::begin(), tree_children_t<data_t>::end());
    }

    tree_node_t<data_t> &operator[](size_t index) const
    {
        const auto &child = this->at(index);
        return static_cast<tree_node_t<data_t> &>(*child);
    }

    tree_node_ptr_t<data_t> get_child_ptr(size_t index) const
    {
        tree_node_ptr_t<data_t> child = this->at(index);
        return child;
    }

    tree_node_t<data_t> &operator<<(const tree_node_ptr_t<data_t> node)
    {
        node->parent = this;
        this->push_back(node);
        return static_cast<tree_node_t<data_t> &>(*this);
    }

    size_t size() const
    {
        return tree_children_t<data_t>::size();
    }

    virtual std::string descData() const
    {
        return "";
    }

    template <typename func_t>
    void foreach (func_t f) const
    {
        auto nodeF = [=](tree_children_t<data_t>::const_reference ref)
        {
            f(*ref);
        };
        for_each(tree_children_t<data_t>::begin(), tree_children_t<data_t>::end(), nodeF);
    }

    template <typename func_t>
    void traverse(func_t f) const
    {
        f(*this);
        foreach (
            [=](tree_node_t<data_t> &ref)
            { ref.traverse(f); })
            ;
    }

    template <typename func_t>
    void traverse(func_t f, int &level, int &index)
    {
        tree_node_t<data_t> &self = *this;
        f(self);
        level++;
        int tmpIdx = index++;
        index = 0;
        foreach (
            [&](tree_node_t<data_t> &ref)
            {
                ref.traverse(f, level, index);
                index++;
            })
            ;
        level--;
        index = tmpIdx;
    }

    template <typename func_t>
    void postorder(func_t f) const
    {
        foreach (
            [=](tree_node_t<data_t> &ref)
            { ref.postorder(f); })
            ;
        f(*this);
    }

    template <typename func_t>
    void postorder(func_t f, int &level, int &index)
    {
        tree_node_t<data_t> &self = *this;
        level++;
        int tmpIdx = index++;
        index = 0;
        foreach (
            [&](tree_node_t<data_t> &ref)
            {
                ref.postorder(f, level, index);
                index++;
            })
            ;
        level--;
        index = tmpIdx;
        f(self);
    }

    std::string dumpTree()
    {
        std::stringstream ss;
        std::vector<bool> visible;
        int level = 0;
        int index = 0;
        traverse(
            [&](tree_node_t<data_t> &node)
            {
                if (visible.size() <= level)
                    visible.push_back(true);
                if (level > 0)
                {
                    if (node.parent == nullptr)
                    {
                        warn << "DumpTree: Node <" << node.descData() << "> has no parent!" << std::endl;
                    }
                    else if (index == node.parent->size() - 1)
                    {
                        visible[level - 1] = false;
                    }
                }
                auto getHead = [=](int level) -> std::string
                {
                    int i = 0;
                    std::string ret;
                    while (i < level - 1)
                    {
                        if (visible[i])
                            ret += "|  ";
                        else
                            ret += "   ";
                        i++;
                    }
                    if (level > 0)
                        ret += "|--";
                    return ret;
                };
                ss << getHead(level);
                ss << node.descData();
                ss << std::endl;
                if (level > 0)
                    for (int i = level; i < visible.size(); i++)
                        visible[i] = true;
            },
            level, index);
        return ss.str();
    }

    void print()
    {
        std::cout << this->dumpTree();
    }
};
```

详情请查看源码，下面所用到的**语法解析树**就是此模板的一个实例类。

#### 2.5.2 在语法分析的过程中构建具象语法树CST

具象语法树（**Concrete Syntax Tree，CST**）是一种表示编程语言文本的语法结构树（或语法解析树），它是由编译器或解释器根据编程语言的上下文无关文法和词法分析器生成的。CST **反映了源代码的具体结构**，包含了语言的**所有细节和特性**，方便编译器或解释器进行后续的语义分析和代码生成。

CST 通常由一个或多个节点组成，每个节点表示源代码中的一个语法结构，如变量声明、函数定义、循环语句等。节点之间的关系通过边来表示，例如父子关系、兄弟关系等。CST 的**根节点代表整个程序**，而**叶子节点则代表程序中最基本的语法单位**，如标识符、操作符等。

CST 与抽象语法树（AST）相似，但它们有一些不同之处。CST 包含了源代码中的**所有细节和特性**，包括关键字、括号等，而 AST 则去除了这些细节，只保留了源代码中的**重要语义结构**。CST 还包含了**类型信息和位置信息**，方便后续的语义分析和代码生成。

以ESLR分析器为例，展示相关核心代码如下：

```C++
/**
 * @brief ESLR核心分析过程，用于解析输入的token序列并构建CST
 *
 * @param input 输入的token序列
 * @param code 上下文浏览器，这里仅用于在出错时打印相关上下文信息
 * @return true 解析成功
 * @return false 解析失败
 */
bool ExtendedSimpleLR1Parser::parse(vector<token> &input, const ContextViewer &code)
{
    info << "ExtendedSimpleLR1Parser: Parsing..." << endl;
    // 初始化，将输入的token序列添加一个结束符号
    // 将输入的token序列转换为TokenViewer，方便后续遍历
    input.push_back(token(make_shared<symbol_t>(SYM_END), SYM_END, 0, 0));
    TokenViewer viewer(input);
    // 初始化栈
    stack<symbol_t> symStk;       // 符号栈
    stack<state_id_t> stateStk;   // 状态栈
    stack<pst_node_ptr_t> cstStk; // 解析树栈（CST）
    symStk.push(SYM_END);         // 符号栈初始加入结束符号
    stateStk.push(0);             // 状态栈初始加入状态 0
    // 初始化表头（用于打印输出分析过程）
    tb_head | "Symbol/State" | "Input" | "Action";
    set_row | AL_CTR;
    token &tok = viewer.current();
    while (!stateStk.empty() && !symStk.empty() && !viewer.ends())
    {
        // 逐步遍历输入流，直到输入流结束
        tok = viewer.current();                         // 获取输入流的当前token
        state_id_t s = stateStk.top();                  // 获取状态栈的栈顶状态
        symbol_t a = *(tok.type);                       // 获取输入流的当前token代表的终结符
        action_t &act = grammar.slr1Table[mkcrd(s, a)]; // 获取当前状态和当前终结符在SLR1分析表中对应的动作
        // 打印输出分析过程
        string act1, act2;
        tie(act1, act2) = descAction(act); // 将动作转换为字符串，用于打印输出
        // 将当前符号栈、状态栈、输入流和动作添加到打印表格中
        new_row | Cell(descStack(symStk)) & AL_LFT | Cell(a) & AL_LFT | Cell(act1) & AL_LFT;
        new_row | descStack(stateStk) | Cell(descTokVecFrom(input, viewer.pos())) & AL_RGT | Cell(act2) & AL_RGT;
        tb_line();
        // 根据动作类型进行相应的处理
        if (holds_alternative<shift_t>(act))
        {
            // 移进动作
            shift_t shift = get<shift_t>(act); // 获取移进动作对应的状态
            symStk.push(a);                    // 将当前终结符压入符号栈
            stateStk.push(shift);              // 将移进动作对应的状态压入状态栈
            // 创建一个新的CST叶子节点，将当前终结符作为其数据
            pst_node_ptr_t node = pst_tree_t::createNode(TERMINAL, tok.value, tok.line, tok.col);
            cstStk.push(node); // 将新的CST节点压入解析树栈
            viewer.advance();  // 将输入流向前移动一个token
        }
        else if (holds_alternative<reduce_t>(act))
        {
            // 规约动作
            product_t &reduce = get<reduce_t>(act).get(); // 获取规约动作对应的产生式
            symbol_t left = reduce.first;                 // 获取产生式左部
            symstr_t right = reduce.second;               // 获取产生式右部
            size_t len = right.size();                    // 获取产生式右部长度（即规约长度）
            // 创建一个新的CST非叶子节点，将产生式左部作为其数据
            // 该节点的子节点为规约长度个数的CST节点，这些CST节点是从解析树栈中弹出的
            pst_node_ptr_t node = pst_tree_t::createNode(NON_TERM, left, 0, 0);
            node->attachProduct(reduce); // 将产生式信息附加到新的CST节点上，便于后续构建RST和AST
            for (size_t i = 0; i < len; i++)
            {
                // 从解析树栈中弹出规约长度个数的CST节点，并添加到新的CST节点中
                // 这里是逆序添加，因为解析树栈中的CST节点是按照规约顺序压入的
                // 符号栈和状态栈中的元素也相应地弹出
                symStk.pop();
                stateStk.pop();
                *node << cstStk.top();
                cstStk.pop();
            }
            // 将新的CST节点的子节点顺序逆转，保证其顺序与产生式右部一致
            node->reverseChildren();
            symStk.push(left); // 将产生式左部压入符号栈
            cstStk.push(node); // 将新的CST节点压入解析树栈
            // 根据产生式左部和当前状态在goto表中查找，得到下一个状态
            action_t &nAct = grammar.slr1Table[mkcrd(stateStk.top(), left)];
            if (holds_alternative<shift_t>(nAct))
                stateStk.push(get<shift_t>(nAct)); // 如果下一个状态是移进状态，将新的状态号压入状态栈
            else if (holds_alternative<accept_t>(nAct) && get<accept_t>(nAct))
                goto accept; // 如果下一个状态是接受状态，说明分析成功，跳转到接受处理部分
            else
                goto reject; // 如果下一个状态是错误状态，说明分析失败，跳转到拒绝处理部分
        }
        // 接受动作
        else if (holds_alternative<accept_t>(act) && get<accept_t>(act))
            goto accept;
        else // 错误动作
            goto reject;
    }
reject: // 拒绝处理部分
    error << "ExtendedSimpleLR1Parser: Parsing failed!" << endl;
    new_row | TB_TAB | MD_TAB | Cell("Rejected") & FORE_RED;
    std::cout << tb_view(); // 打印输出分析表格
    info << "ExtendedSimpleLR1Parser: Related context:" << endl;
    tok = viewer.current();               // 获取当前token
    code.printContext(tok.line, tok.col); // 打印当前Token的相关上下文信息
    info << "ExtendedSimpleLR1Parser: Remaining cst nodes:" << endl;
    // 打印输出分析栈中剩余的CST节点，便于找出问题
    printRemainingTreeNodes(cstStk);
    return false;
accept: // 接受处理部分
    info << "ExtendedSimpleLR1Parser: Parsing succeed!" << endl;
    // 获取文法开始符号对应的产生式
    grammar.updateStartProduct();
    product_t &startProduct = grammar.startProduct;
    symstr_t &right = startProduct.second;
    // 创建一个新的CST根节点（整个CST的根节点），将文法开始符号作为其数据
    pst_node_ptr_t startNode = pst_tree_t::createNode(NON_TERM, grammar.symStart, 0, 0);
    startNode->attachProduct(startProduct); // 将文法开始符号对应的产生式信息附加到新的CST节点上
    for (size_t i = 0; i < right.size(); i++)
    {
        // 从解析树栈中弹出规约长度个数的CST节点，并添加到CST根节点中
        symStk.pop();
        stateStk.pop();
        *startNode << cstStk.top();
        cstStk.pop();
    }
    // 将CST根节点的子节点顺序逆转，保证其顺序与产生式右部一致
    startNode->reverseChildren();
    // 最终CST树的根节点即为文法开始符号对应的CST节点
    cst = startNode;
    // 打印输出分析表格
    new_row | Cell(descStack(symStk)) & AL_LFT | MD_TAB | Cell("Accepted") & FORE_GRE;
    std::cout << tb_view();
    return true;
}
```

上述过程分析得到的CST的部分结果如下：

```
Program <Program -> Program_star_1>
|--Program_star_1 <Program_star_1 -> FuncDeclStmt Program_star_1>
   |--FuncDeclStmt <FuncDeclStmt -> decl FuncDecl ;>
   |  |--`decl` at <5:4>
   |  |--FuncDecl <FuncDecl -> func Ident ( FuncDecl_opti_1 ) FuncDecl_opti_2>
   |  |  |--`func` at <5:9>
   |  |  |--`add` at <5:13>
   |  |  |--`(` at <5:14>
   |  |  |--FuncDecl_opti_1 <FuncDecl_opti_1 -> ParamList>
   |  |  |  |--ParamList <ParamList -> Param ParamList_star_1>
   |  |  |     |--Param <Param -> Ident : VarType Param_star_1>
   |  |  |     |  |--`x` at <5:15>
   |  |  |     |  |--`:` at <5:17>
   |  |  |     |  |--VarType <VarType -> int>
   |  |  |     |  |  |--`int` at <5:21>
   |  |  |     |  |--Param_star_1 <Param_star_1 -> >
   |  |  |     |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
   |  |  |        |--`,` at <5:22>
   |  |  |        |--Param <Param -> Ident : VarType Param_star_1>
   |  |  |        |  |--`y` at <5:24>
   |  |  |        |  |--`:` at <5:26>
   |  |  |        |  |--VarType <VarType -> int>
   |  |  |        |  |  |--`int` at <5:30>
   |  |  |        |  |--Param_star_1 <Param_star_1 -> >
   |  |  |        |--ParamList_star_1 <ParamList_star_1 -> >
```

观察上述CST可以发现，其中信息非常丰富，但包含了许多我们并不关心乃至并不想要的内容。这部分信息主要包括两点。

其一，我们不需要诸如`for`、`while`、`(`等**关键字或者运算符**信息。这些信息本质上是用来**辅助语法分析器归纳语义结构**的，但在我们后序的分析阶段这些并不重要。我们可以通过CST上的非终结符结点来获知当前结点的语义结构，而无需通过这些关键词去识别。因此，这部分信息需要从树上**抹除**。上述CST精简后可以得到如下结构：

```
Program <Program -> Program_star_1>
|--Program_star_1 <Program_star_1 -> FuncDeclStmt Program_star_1>
   |--FuncDeclStmt <FuncDeclStmt -> decl FuncDecl ;>
   |  |--FuncDecl <FuncDecl -> func Ident ( FuncDecl_opti_1 ) FuncDecl_opti_2>
   |     |--`add` at <5:13>
   |     |--FuncDecl_opti_1 <FuncDecl_opti_1 -> ParamList>
   |     |  |--ParamList <ParamList -> Param ParamList_star_1>
   |     |     |--Param <Param -> Ident : VarType Param_star_1>
   |     |     |  |--`x` at <5:15>
   |     |     |  |--VarType <VarType -> int>
   |     |     |  |  |--`int` at <5:21>
   |     |     |  |--Param_star_1 <Param_star_1 -> >
   |     |     |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
   |     |        |--Param <Param -> Ident : VarType Param_star_1>
   |     |        |  |--`y` at <5:24>
   |     |        |  |--VarType <VarType -> int>
   |     |        |  |  |--`int` at <5:30>
   |     |        |  |--Param_star_1 <Param_star_1 -> >
   |     |        |--ParamList_star_1 <ParamList_star_1 -> >
```

其二，CST上的某些节点结构并不便于我们分析。EBNF为我们提供了**重复和可选**的表达语义，语法分析器实际上是需要先将根据这些语义生成相应的新的产生式才能完成语义分析的。这些产生式是**程序额外添加进来**的，并不是我们所掌握的信息。例如，我们不希望得到类似下面的**递归**结构：

```
|--ParamList <ParamList -> Param ParamList_star_1>
   |--Param <Param -> Ident : VarType Param_star_1>
   |  |--`x` at <6:16>
   |  |--VarType <VarType -> int>
   |  |  |--`int` at <6:22>
   |  |--Param_star_1 <Param_star_1 -> >
   |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
      |--Param <Param -> Ident : VarType Param_star_1>
      |  |--`y` at <6:25>
      |  |--VarType <VarType -> int>
      |  |  |--`int` at <6:31>
      |  |--Param_star_1 <Param_star_1 -> >
      |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
         |--Param <Param -> Ident : VarType Param_star_1>
         |  |--`z` at <6:34>
         |  |--VarType <VarType -> real>
         |  |  |--`real` at <6:41>
         |  |--Param_star_1 <Param_star_1 -> >
         |--ParamList_star_1 <ParamList_star_1 -> , Param ParamList_star_1>
            |--Param <Param -> Ident : VarType Param_star_1>
            |  |--`s` at <6:44>
            |  |--VarType <VarType -> str>
            |  |  |--`str` at <6:50>
            |  |--Param_star_1 <Param_star_1 -> >
            |--ParamList_star_1 <ParamList_star_1 -> >
```

而希望程序能够**隐去**其自动添加的产生式（也就是让这部分对用户**透明**），帮我们整理成如下格式：

```
|--ParamList <ParamList -> Param ParamList_star_1>
   |--Param <Param -> Ident : VarType Param_star_1>
   |  |--`x` at <6:16>
   |  |--VarType <VarType -> int>
   |  |  |--`int` at <6:22>
   |  |--StarList <Param_star_1 -> >
   |--Param <Param -> Ident : VarType Param_star_1>
   |  |--`y` at <6:25>
   |  |--VarType <VarType -> int>
   |  |  |--`int` at <6:31>
   |  |--StarList <Param_star_1 -> >
   |--Param <Param -> Ident : VarType Param_star_1>
   |  |--`z` at <6:34>
   |  |--VarType <VarType -> real>
   |  |  |--`real` at <6:41>
   |  |--StarList <Param_star_1 -> >
   |--Param <Param -> Ident : VarType Param_star_1>
      |--`s` at <6:44>
      |--VarType <VarType -> str>
      |  |--`str` at <6:50>
      |--StarList <Param_star_1 -> >
```

#### 2.5.3 删去CST中冗余信息得到简化语法树RST

经过了上述观察，我们便确定了努力方向。

首先简化CST得到RST，相关核心代码和说明如下：

```C++
/**
 * @brief 精简CST，将其转换为RST
 *
 * @return pst_tree_ptr_t 精简后的RST根节点
 */
pst_tree_ptr_t ExtendedSimpleLR1Parser::reduceCST()
{
    info << "ExtendedSimpleLR1Parser: Reducing CST... (CST->RST)" << endl;
    const Grammar &g = this->grammar;
    symset_t &mulTerms = grammar.mulTerms;
    symset_t &nonTerms = grammar.nonTerms;
    symset_t &terminals = grammar.terminals;
    // 用于构建RST的节点栈
    // 这里并不是在原来的CST上进行修改，而是在遍历CST的过程中挑选有用的信息构建新的RST
    stack<pst_node_ptr_t> rstStk;
    // 后序遍历CST，同时利用栈保存遍历过程中的节点，自底向上构建RST
    cst->postorder(
        [&](pst_node_t node)
        {
            // 创建新的RST节点
            pst_node_ptr_t rstNode = pst_tree_t::createNode(node.data);
            // 如果当前节点代表非终结符，按照其产生式构造简化的RST节点
            // 因为是后序遍历，所以子节点已经被压入栈中了
            // 如果当前节点代表终结符，直接压入栈中并返回即可
            if (node.data.type == NON_TERM)
            {
                assert(node.data.product_opt.has_value());
                product_t &product = node.data.product_opt.value();
                symstr_t &right = product.second;
                rstNode->attachProduct(product);
                // 如果产生式右部只有一个终结符，那么将其作为RST节点的数据保留
                if (right.size() == 1 && _find(terminals, right[0]))
                {
                    pst_node_ptr_t child = rstStk.top();
                    rstStk.pop();
                    *rstNode << child;
                }
                else
                {
                    // 逆序遍历子节点，将其弹出栈并添加到新的RST节点中
                    for (auto it = right.rbegin(); it != right.rend(); it++)
                    {
                        pst_node_ptr_t child = rstStk.top();
                        rstStk.pop();
                        // RST节点仅保留非终结符（non-term）和带有映射信息的字面量终结符（mul-term）
                        if (_find(nonTerms, *it) || _find(mulTerms, *it))
                        {
                            *rstNode << child;
                        }
                    }
                    // 逆转子节点顺序
                    rstNode->reverseChildren();
                }
            }
            // 将新的RST节点压入栈中
            rstStk.push(rstNode);
        });
    // 最后栈中只剩下一个RST节点，即为最终的RST
    rst = rstStk.top();
    return rst;
}
```

上面的代码主要利用了我实现的抽象树的**后序遍历**方法，并在遍历的过程中传入一个**Lambda匿名函数**，在遍历CST的**同时**构建出精简的RST。

#### 2.5.4 重构RST的语义结构得到抽象语法树AST

得到RST后，我们考虑将其重构，识别其中的递归重复和可选结构，将其重组为新的结构。

对于**递归重复**的结构，我们做如下处理：

```C++
/**
 * @brief 重构AST节点，将该节点的右递归子节点平铺
 *
 * @param astNode 需要处理的AST节点
 * @param indexes 需要处理的子节点的索引
 */
void refactorStarListNode(pst_node_ptr_t astNode, vector<size_t> indexes)
{
    for (auto idx : indexes)
    {
        pst_node_ptr_t target = astNode->getChildAt(idx);
        // 创建一个新的AST节点，将原来的子节点遍历处理后添加到新的节点中
        pst_node_ptr_t listNode = pst_tree_t::createNode(target->data);
        // 新节点的命名为StarList，便于后续处理
        listNode->data.symbol = "StarList";
        // 递归遍历子节点
        function<void(pst_node_ptr_t)> traverse = [&](pst_node_ptr_t node)
        {
            const vector<pst_node_ptr_t> &children = node->getChildren();
            if (children.size() > 0)
            {
                // 将各层的非右递归子节点直接平铺添加的要处理的根节点中
                for (int i = 0; i < children.size() - 1; i++)
                {
                    *listNode << children[i];
                }
                // 在右递归的子结点中，最后一个子结点还是右递归的子结点
                traverse(children.back());
            }
        };
        traverse(target);
        // 用新节点替换原来的节点
        astNode->replace(idx, listNode);
        // 下面进行AST简化整合
        if (astNode->getChildren().size() == 1)
        {
            // 如果当前节点只有一个子节点，说明其只有一个ListNode节点
            // 此时删掉ListNode节点，将其子节点提升到当前节点
            const vector<pst_node_ptr_t> &children = listNode->getChildren();
            astNode->pop_back();
            for (auto &child : children)
            {
                *astNode << child;
            }
        }
        else if (astNode->getChildren().size() == 2)
        {
            // 如果当前节点有两个子节点，说明其有一个ListNode节点和一个非ListNode节点
            // 此时判断非ListNode节点是否与ListNode节点的子节点是同类型
            // 如果是，则将ListNode子节点提升到当前节点，删掉ListNode节点
            const vector<pst_node_ptr_t> &children = listNode->getChildren();
            pst_node_ptr_t nonListNode = astNode->getChildAt(0);
            if (children.size() == 0)
            {
                astNode->pop_back();
                continue;
            }
            if (nonListNode->data.symbol == children[0]->data.symbol)
            {
                astNode->pop_back();
                for (auto &child : children)
                {
                    *astNode << child;
                }
            }
        }
    }
}
```

对于**可选结构**，我们只需做一些**标记**即可：

```C++
/**
 * @brief 重构AST节点，将该节点的可选子节点标记为Optional
 *
 * @param astNode 需要处理的AST节点
 * @param indexes 需要处理的子节点的索引
 */
void refactorOptionalNode(pst_node_ptr_t astNode, vector<size_t> indexes)
{
    vector<pst_node_ptr_t> &children = astNode->getChildren();
    for (auto idx : indexes)
    {
        children[idx]->data.symbol = "Optional";
    }
}
```

再有了上面两个处理方法的基础上，我们遍历RST，一边识别其复合的结构特征，一边**自底向上**重新构筑AST：

```C++
/**
 * @brief 重构RST，将其转换为AST
 *
 * @return pst_tree_ptr_t 重构后的AST根节点
 */
pst_tree_ptr_t ExtendedSimpleLR1Parser::refactorRST()
{
    info << "ExtendedSimpleLR1Parser: Refactoring RST... (RST->AST)" << endl;
    // 用于构建AST的节点栈
    // 重构的思路与精简CST类似，依然是在遍历RST的过程构建新的AST
    // 只是这里是并不是挑选有用的信息，而是构建的同时调用相应的函数进行重构处理
    stack<pst_node_ptr_t> astStk;
    // 后序遍历RST，同时利用栈保存遍历过程中的节点，自底向上构建AST
    rst->postorder(
        [&](pst_node_t node)
        {
            // 创建新的AST节点
            pst_node_ptr_t astNode = pst_tree_t::createNode(node.data);
            // 如果当前节点代表非终结符，先将栈中的子节点弹出并添加到新的AST节点中
            // 而后检查其产生式是否包含特殊非终结符（隐含有运算符信息）
            // 如果包含，则调用相应的函数进行处理
            // 如果当前节点代表终结符，直接压入栈中并返回即可
            if (node.data.type == NON_TERM)
            {
                assert(node.data.product_opt.has_value());
                product_t &product = node.data.product_opt.value();
                // 将产生式简化为仅包含有用信息的产生式
                reduced_product_t reducedProduct = grammar.reduceProduct(product);
                symbol_t &left = reducedProduct.first;
                symstr_t &right = reducedProduct.second;
                // 记录产生式中特殊非终结符的位置
                // 特殊非终结符包括：_star_（表示0或多次）、_opti_（表示0或1次）
                // 这些特殊的非终结符是在EBNF解析的过程中添加的
                // 在语法分析时，这些特殊非终结符会被记录在CST中
                // 在完成语法分析后，这些程序自动添加的特殊非终结符就可以被删除了
                // 最后只留下用户自定义的非终结符构成的AST，便于后续语义分析的过程
                static vector<size_t> starIndexes, optiIndexes;
                starIndexes.clear();
                optiIndexes.clear();
                // 逆序遍历子节点，将其弹出栈并添加到新的AST节点中
                for (size_t i = right.size() - 1; i != -1; i--)
                {
                    symbol_t &s = right[i];
                    pst_node_ptr_t child = astStk.top();
                    astStk.pop();
                    *astNode << child;
                    // 如果右部有特殊非终结符，记录其位置
                    if (s.find("_star_") != string::npos)
                    {
                        starIndexes.push_back(i);
                    }
                    else if (s.find("_opti_") != string::npos)
                    {
                        optiIndexes.push_back(i);
                    }
                }
                // 逆转子节点顺序
                astNode->reverseChildren();
                // 处理特殊非终结符
                // 如果左部有特殊非终结符，说明不需要做额外处理
                // 因为我们需要向上找到第一个不含特殊非终结符的左部产生式，再统一处理
                if (optiIndexes.size() > 0)
                    refactorOptionalNode(astNode, optiIndexes); // 处理Optional节点
                if (left.find("_star_") == string::npos && starIndexes.size() > 0)
                    refactorStarListNode(astNode, starIndexes); // 处理StarList节点
            }
            // 将新的RST节点压入栈中
            astStk.push(astNode);
        });
    // 最后栈中只剩下一个AST节点，即为最终的AST
    ast = astStk.top();
    return ast;
}
```

经过上述步骤得到的AST，就可以进行下一步的处理了。

### 2.6 类LLVM IR的中间表示生成

关于中间表示，我采用了LLVM IR的规范。这个IR本质上仍是**三地址码**，只不过能够关注更多的细节，并且在**工程实践上更有实际价值**。

#### 2.6.1 LLVM IR简介

LLVM IR（**LLVM Intermediate Representation**）是 LLVM （Low-Level Virtual Machine）编译器框架中的一种中间代码表示形式，它**类似于汇编语言**，但比汇编语言更高级，但比常见的编程语言更低级。

LLVM IR 的设计初衷是为了提供一种通用的中间代码表示形式，可以被多种编程语言的前端所使用，并且可以被编译成多种目标平台的机器码。LLVM IR 具有以下特点：

1. 类型安全：LLVM IR 代码中的每个值都有一个明确的类型，并且类型检查是在编译时进行的，可以帮助开发者避免类型错误。
2. 抽象：LLVM IR 代码中的指令和操作符可以看作是高级语言中的语法结构，可以方便地表示程序的逻辑结构和算法。
3. 可移植性：LLVM IR 代码可以被编译成多种目标平台的机器码，具有**很好的可移植性和可扩展性**。

在 LLVM 编译器框架中，LLVM IR 通常是前端将源代码编译成的中间代码表示形式，经过优化和转换后再生成目标平台的机器码。同时，LLVM IR 代码也可以手动编写，用于实现一些特殊的编译器优化或调试功能。

使用 LLVM IR 作为个人实现编译器的输出结果有以下优势：

1. 简单：LLVM IR 代码比目标平台的汇编语言更容易理解和调试，可以帮助开发者更快速地实现编译器的各个阶段。
2. 可移植：LLVM 编译器可以将 LLVM IR 代码编译成多种目标平台的机器码，可以帮助开发者更方便地测试和验证编译器的正确性和性能。
3. 高效：LLVM 编译器框架具有优秀的优化能力，可以将 LLVM IR 代码优化成更高效的机器码，从而提高程序的性能。

#### 2.6.2 RSC类型数据引用链体系设计

在进行**中间代码生成**的过程中，我刻意考虑了**后端代码优化**所需要的信息，设计并实现了**类型数据引用链**。其本质是**一组继承关系**，标记了值和指令互相之间的**使用关系**，有助于后序分析数据流等**优化**操作。

涉及到的核心数据声明如下：

```C++
class Value;
class User;
class Use;
using use_ptr_t = std::shared_ptr<Use>;
#define make_use(value, user) std::make_shared<Use>(value, user)
using user_ptr_t = std::shared_ptr<User>;
#define make_user(type, name) std::make_shared<User>(type, name)
using value_ptr_t = std::shared_ptr<Value>;
#define make_value(type, name) std::make_shared<Value>(type, name)
```

在这里，Value代表值的概念，三地址码（或者是LLVM的指令）本质上都是Value，他们有自己的名字和类型，并支持作为值被其他指令引用。User继承自Value，是所有指令的基类。Use代表User和Value的引用关系，用于后端代码优化。

相应的，还有针对RSC设计的类型系统，简要定义如下：

```C++
class Type;
using type_ptr_t = std::shared_ptr<Type>;

class PrimitiveType;
using prim_ptr_t = std::shared_ptr<PrimitiveType>;
#define make_prime_type(type) std::make_shared<PrimitiveType>(type)

class PointerType;
using ptr_ptr_t = std::shared_ptr<PointerType>;
#define make_ptr_type(type) std::make_shared<PointerType>(type)
```

由于时间和篇幅不足，这部分不再展开讨论，感兴趣请参阅源码。

#### 2.6.3 符号表和分析上下文的设计

RSC支持作用域的概念。在语义分析过程中，Visitor会维护一个上下文，上下文中存储了遍历不同节点时需要共享的信息。其中之一便是符号表。

符号表的定义如下：

```C++
using scope_t = NestedMap<std::string, user_ptr_t>;
using scope_ptr_t = std::shared_ptr<scope_t>;

class SymbolTable
{
    std::stack<scope_ptr_t> tableStk;

public:
    void newScope();
    std::list<user_ptr_t> popScope();
    [[nodiscard]] user_ptr_t find(const std::string &name);
    [[nodiscard]] user_ptr_t registerAlloca(const std::string &name, type_ptr_t type);
    [[nodiscard]] user_ptr_t registerGlobal(const std::string &name, type_ptr_t type, const_val_ptr_t init);
};
```

可见，符号表的本质是一个**作用域栈**。在这里，**作用域的**本质是`NestedMap`，即可以**递归嵌套的哈希表**。这样的数据结构，保证了我们可以在子作用域中访问父作用域的符号信息，而不能相反。进入一个作用域时，程序可以调用`newScope`函数得到全新的子作用域，退出时可以调用`popScope`弹出作用域并获取该子作用域中的所有符号定义。顺带一提，全局变量本质上是在根作用域上定义的符号变量。

Visitor上下文中，除了符号表，还有管理函数声明的函数表，其定义如下：

```C++
class FunctionTable
{
    std::map<std::string, func_ptr_t> table;

public:
    void insert(const std::string &name, func_ptr_t func) { table.insert({name, func}); }
    [[nodiscard]] func_ptr_t find(const std::string &name) const
    {
        auto it = table.find(name);
        if (it != table.end())
        {
            return it->second;
        }
        return nullptr;
    }
    [[nodiscard]] bool has(const std::string &name) const { return table.find(name) != table.end(); }
    [[nodiscard]] func_ptr_t registerFunction(const std::string &name, prim_ptr_t type)
    {
        func_ptr_t func = make_func(name, type);
        table.insert({name, func});
        return func;
    }
};
```

时间原因，不展开讲解。

#### 2.6.4 LLVM Instruction设计与定义

下面给出了我实现的LLVM指令的声明，定义请查看源码。

```C++
class LabelInstr;
using label_ptr_t = std::shared_ptr<LabelInstr>;
#define make_label(name) std::make_shared<LabelInstr>(name)
#define cast_label(instr) std::dynamic_pointer_cast<LabelInstr>(instr)

// Memory Access and Addressing Operations （内存访问和寻址操作）
class AllocaInstr;
using alloca_ptr_t = std::shared_ptr<AllocaInstr>;
#define make_alloca(name, type) std::make_shared<AllocaInstr>(name, type)
#define cast_alloca(instr) std::dynamic_pointer_cast<AllocaInstr>(instr)

class GlobalInstr;
using global_ptr_t = std::shared_ptr<GlobalInstr>;
#define make_global(name, type, value) std::make_shared<GlobalInstr>(name, type, value)
#define cast_global(instr) std::dynamic_pointer_cast<GlobalInstr>(instr)

class LoadInstr;
using load_ptr_t = std::shared_ptr<LoadInstr>;
#define make_load(from) std::make_shared<LoadInstr>(from)
#define cast_load(instr) std::dynamic_pointer_cast<LoadInstr>(instr)

class StoreInstr;
using store_ptr_t = std::shared_ptr<StoreInstr>;
#define make_store(from, to) std::make_shared<StoreInstr>(from, to)
#define cast_store(instr) std::dynamic_pointer_cast<StoreInstr>(instr)

class GEPInstr; // GetElementPtr
using gep_ptr_t = std::shared_ptr<GEPInstr>;

// Function Call Instructions （函数调用和返回指令）
class FuncInstr; // 抽象指令，由其他指令组合而成
using func_ptr_t = std::shared_ptr<FuncInstr>;
#define make_func(name, retType) std::make_shared<FuncInstr>(name, retType)
#define cast_func(instr) std::dynamic_pointer_cast<FuncInstr>(instr)

class CallInstr;
using call_ptr_t = std::shared_ptr<CallInstr>;
#define make_call(func) std::make_shared<CallInstr>(func)
#define cast_call(instr) std::dynamic_pointer_cast<CallInstr>(instr)

// Terminator Instructions （终端指令）
class RetInstr;
using ret_ptr_t = std::shared_ptr<RetInstr>;
#define make_ret(retval) std::make_shared<RetInstr>(retval)
#define cast_ret(instr) std::dynamic_pointer_cast<RetInstr>(instr)

class BrInstr;
using br_ptr_t = std::shared_ptr<BrInstr>;
#define make_br(cond) std::make_shared<BrInstr>(cond)
#define cast_br(instr) std::dynamic_pointer_cast<BrInstr>(instr)

class JmpInstr; // 无条件跳转
using jmp_ptr_t = std::shared_ptr<JmpInstr>;
#define make_jmp(target) std::make_shared<JmpInstr>(target)
#define cast_jmp(instr) std::dynamic_pointer_cast<JmpInstr>(instr)

// Unary Operations （一元运算）
class NegInstr;
using neg_ptr_t = std::shared_ptr<NegInstr>;
#define make_neg(from, opType) std::make_shared<NegInstr>(from, opType)
#define cast_neg(instr) std::dynamic_pointer_cast<NegInstr>(instr)

// Binary Operations （二元运算）
class AddInstr;
using add_ptr_t = std::shared_ptr<AddInstr>;
#define make_add(lhs, rhs, opType) std::make_shared<AddInstr>(lhs, rhs, opType)
#define cast_add(instr) std::dynamic_pointer_cast<AddInstr>(instr)

class SubInstr;
using sub_ptr_t = std::shared_ptr<SubInstr>;
#define make_sub(lhs, rhs, opType) std::make_shared<SubInstr>(lhs, rhs, opType)
#define cast_sub(instr) std::dynamic_pointer_cast<SubInstr>(instr)

class MulInstr;
using mul_ptr_t = std::shared_ptr<MulInstr>;
#define make_mul(lhs, rhs, opType) std::make_shared<MulInstr>(lhs, rhs, opType)
#define cast_mul(instr) std::dynamic_pointer_cast<MulInstr>(instr)

class DivInstr;
using div_ptr_t = std::shared_ptr<DivInstr>;
#define make_div(lhs, rhs, opType) std::make_shared<DivInstr>(lhs, rhs, opType)
#define cast_div(instr) std::dynamic_pointer_cast<DivInstr>(instr)

class RemInstr;
using rem_ptr_t = std::shared_ptr<RemInstr>;
#define make_rem(lhs, rhs, opType) std::make_shared<RemInstr>(lhs, rhs, opType)
#define cast_rem(instr) std::dynamic_pointer_cast<RemInstr>(instr)

class CmpInstr;
using cmp_ptr_t = std::shared_ptr<CmpInstr>;
#define make_cmp(lhs, rhs, opType, cmpType) std::make_shared<CmpInstr>(lhs, rhs, opType, cmpType)
#define cast_cmp(instr) std::dynamic_pointer_cast<CmpInstr>(instr)

// Block and Program
class InstrBlock;
using block_ptr_t = std::shared_ptr<InstrBlock>;
#define make_block(name) std::make_shared<InstrBlock>(name)
#define cast_block(instr) std::dynamic_pointer_cast<InstrBlock>(instr)

class Program;
using program_ptr_t = std::shared_ptr<Program>;
#define make_program() std::make_shared<Program>()
#define cast_program(instr) std::dynamic_pointer_cast<Program>(instr)

// Constant Values
class Constant;
using const_val_ptr_t = std::shared_ptr<Constant>;
#define cast_const(instr) std::dynamic_pointer_cast<Constant>(instr)

class ConstantInt;
using const_int_ptr_t = std::shared_ptr<ConstantInt>;
#define make_const_int(value) std::make_shared<ConstantInt>(value)

class ConstantReal;
using const_real_ptr_t = std::shared_ptr<ConstantReal>;
#define make_const_real(value) std::make_shared<ConstantReal>(value)

class ConstantBool;
using const_bool_ptr_t = std::shared_ptr<ConstantBool>;
#define make_const_bool(value) std::make_shared<ConstantBool>(value)

class ConstantChar;
using const_char_ptr_t = std::shared_ptr<ConstantChar>;
#define make_const_char(value) std::make_shared<ConstantChar>(value)

class ConstantString;
using const_str_ptr_t = std::shared_ptr<ConstantString>;
#define make_const_str(value) std::make_shared<ConstantString>(value)
```

时间原因，不展开讲解。

#### 2.6.5 AST Visitor模式设计与实现

下面给出了Visitor的定义，实现请查看源码：

```C++
class RSCVisitor
{
    Context context;

public:
    program_ptr_t visitProgram(pst_node_ptr_t node);

    ret_info_t visitVarDeclStmt(pst_node_ptr_t node, bool global = false);
    ret_info_t visitVarDecl(pst_node_ptr_t node, bool global = false);
    ret_info_t visitVarDef(pst_node_ptr_t node, bool global = false);

    ret_info_t visitInitVal(pst_node_ptr_t node);

    ret_info_t visitFuncDeclStmt(pst_node_ptr_t node);
    ret_info_t visitFuncDecl(pst_node_ptr_t node);
    ret_info_t visitFuncDef(pst_node_ptr_t node);
    ret_info_t visitFuncCall(pst_node_ptr_t node);

    ret_info_t visitArgList(pst_node_ptr_t node);
    ret_info_t visitParamList(pst_node_ptr_t node);
    ret_info_t visitParam(pst_node_ptr_t node);

    ret_info_t visitStmt(pst_node_ptr_t node);
    ret_info_t visitBlock(pst_node_ptr_t node);
    ret_info_t visitAssignment(pst_node_ptr_t node);
    ret_info_t visitIfStmt(pst_node_ptr_t node);
    ret_info_t visitWhileStmt(pst_node_ptr_t node);
    ret_info_t visitForStmt(pst_node_ptr_t node);
    ret_info_t visitBreakStmt(pst_node_ptr_t node);
    ret_info_t visitContinueStmt(pst_node_ptr_t node);
    ret_info_t visitReturnStmt(pst_node_ptr_t node);
    ret_info_t visitExprStmt(pst_node_ptr_t node);

    ret_info_t visitUnaryExpr(pst_node_ptr_t node);
    ret_info_t visitMulExpr(pst_node_ptr_t node);
    ret_info_t visitExpr(pst_node_ptr_t node);
    ret_info_t visitRelExpr(pst_node_ptr_t node);
    ret_info_t visitAndExpr(pst_node_ptr_t node);
    ret_info_t visitOrExpr(pst_node_ptr_t node);
    ret_info_t visitBoolExpr(pst_node_ptr_t node);

    // factors
    ret_info_t visitFactor(pst_node_ptr_t node);
    ret_info_t visitLVal(pst_node_ptr_t node);
    ret_info_t visitLiteral(pst_node_ptr_t node);
};
```

时间原因，不展开讲解。下面会针对几个比较典型的情况佐以说明。

##### 2.6.5.1 算数和逻辑表达式的翻译

算术表达式典型：

```C++
// MulExpr -> MulExpr ( `*` | `/` | `%` ) UnaryExpr | UnaryExpr
ret_info_t RSCVisitor::visitMulExpr(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting mul expr..." << std::endl;
    assert(
        node->data.symbol == "MulExpr",
        format("Expected node MulExpr, but got $ instead.", node->data.symbol));
    pst_node_ptr_t child = node->firstChild();
    if (child->data.symbol == "UnaryExpr")
    {
        // UnaryExpr
        return visitUnaryExpr(child);
    }

    assert(
        child->data.symbol == "MulExpr",
        format(
            "first child of mul expr should be mul expr or unary expr, but got $",
            child->data.symbol));
    // MulExpr ( `*` | `/` | `%` ) UnaryExpr
    assert(
        node->childrenCount() == 2,
        format("mul expr should have 1 or 2 child(ren), but got $", node->childrenCount()));

    auto lhsInfo = visitMulExpr(child);
    auto rhsInfo = visitUnaryExpr(node->getChildAt(1));

    auto op = getProSymAt(node, 1); // * | / | %

    user_ptr_t lhs = lhsInfo.getValue();
    user_ptr_t rhs = rhsInfo.getValue();

    // 生成相关指令并追加到list之后
    user_ptr_t instr = nullptr;

    if (op == "*")
    {
        instr = make_mul(lhs, rhs, lhs->getType()->getOpType());
    }
    else if (op == "/")
    {
        instr = make_div(lhs, rhs, lhs->getType()->getOpType());
    }
    else if (op == "%")
    {
        instr = make_rem(lhs, rhs, lhs->getType()->getOpType());
    }
    else
    {
        error << "unknown operator" << std::endl;
        exit(1);
    }

    ret_info_t retInfo{list_concat(lhsInfo.instrList, rhsInfo.instrList)};
    retInfo.addInstr(instr);
    retInfo.setValue(instr);

    return retInfo;
}
```

逻辑表达式典型：

```C++
// AndExpr -> AndExpr `&&` RelExpr | RelExpr
ret_info_t RSCVisitor::visitAndExpr(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting and expr..." << std::endl;
    assert(
        node->data.symbol == "AndExpr",
        format("Expected node AndExpr, but got $ instead.", node->data.symbol));
    size_t childNum = node->childrenCount();
    pst_node_ptr_t child = node->firstChild();

    if (childNum == 1 && child->data.symbol == "RelExpr")
    {
        // AndExpr -> RelExpr
        // 直接返回RelExpr的结果即可
        return visitRelExpr(child);
    }

    assert(
        child->data.symbol == "AndExpr",
        format("first child of and expr should be AndExpr or RelExpr, but got $", child->data.symbol));

    assert(
        childNum == 2,
        format("AndExpr should have 1 or 2 child(ren), but got $", childNum));

    // 处理与运算
    auto lhsInfo = visitAndExpr(child);
    auto rhsInfo = visitRelExpr(node->getChildAt(1));

    ret_info_t lhs = lhsInfo;
    ret_info_t rhs = rhsInfo;

    // 对于与运算，需要将lhs和rhs的bb连接起来
    ret_info_t retInfo{lhs.instrList};

    retInfo.appendTrueList(rhs.getTargetsOf(JR_TRUE_EXIT));   // 将rhs的真出口作为retInfo的真出口
    retInfo.appendFalseList(lhs.getTargetsOf(JR_FALSE_EXIT)); // 将lhs的假出口作为retInfo的假出口
    retInfo.appendFalseList(rhs.getTargetsOf(JR_FALSE_EXIT)); // 将rhs的假出口作为retInfo的假出口

    // 将lhs的真出口tc连接到rhs的入口bb entry
    block_ptr_t bb = make_block("and.rhs");
    bb->addInstrList(rhs.instrList);
    retInfo.addInstr(bb);

    lhs.backpatch(JR_TRUE_EXIT, bb);

    return retInfo;
}
```

##### 2.6.5.2 函数声明、定义和调用的翻译

```C++
// FuncDef -> FuncDecl Block
ret_info_t RSCVisitor::visitFuncDef(pst_node_ptr_t node)
{
    assert(
        node->data.symbol == "FuncDef",
        format("Expected node FuncDef, but got $ instead.", node->data.symbol));
    // 首先检查函数是否已经声明
    // 如果已经声明，则需要对比函数声明和函数定义是否一致
    // 如果没有声明，则直接注册函数
    pst_node_ptr_t funcDeclNode = node->firstChild();

    const std::string &identStr = funcDeclNode->firstChild()->data.symbol;
    func_ptr_t func = context.functionTable.find(identStr);

    if (func == nullptr)
    {
        // 函数未声明，直接注册函数
        ret_info_t funcInfo = visitFuncDecl(funcDeclNode);

        func = dynamic_pointer_cast<FuncInstr>(funcInfo.getValue());
    }
    else
    {
        // 函数已声明，检查函数声明和函数定义是否一致
        std::string retTypeStr = "void";
        pst_node_ptr_t retTypeNode = funcDeclNode->getChildAt(2);
        if (retTypeNode->hasChild())
        {
            // 函数声明有返回值类型
            retTypeStr = retTypeNode->firstChild()->firstChild()->data.symbol;
        }
        pst_node_ptr_t paramsNode = funcDeclNode->getChildAt(1);
        if (paramsNode->hasChild())
        {
            // 函数声明有参数
            // 检查函数定义是否有参数
            ret_info_t paramsInfo = visitParamList(paramsNode->firstChild());

            assert(
                func->matchRetType(PrimitiveType::str2type(retTypeStr)) &&
                    func->matchArgs(paramsInfo.valueList),
                "function declaration and definition mismatch.");
        }
    }

    // 新建作用域，访问解析函数体
    context.symbolTable.newScope();

    // 注册函数参数
    for (user_ptr_t param : func->getParams())
    {
        context.symbolTable.registerAlloca(param->getName(), param->getType());
    }

    pst_node_ptr_t blockNode = node->getChildAt(1);
    ret_info_t blockInfo = visitBlock(blockNode);

    // 下面开始构建函数定义

    // 首先构建函数的入口基本块 entry basic block
    block_ptr_t entryBB = make_block("entry");
    // 将函数体内变量的内存分配指令追加到entry之后
    std::list<user_ptr_t> allocas = context.symbolTable.popScope();
    entryBB->addInstrList(allocas);
    // 为函数返回值分配内存
    // alloca_ptr_t retAlloc = make_alloca("retval", func->getRetType());
    // entryBB->addInstr(retAlloc);

    // 构建函数的出口基本块 exit basic block
    // block_ptr_t exitBB = make_block("exit");
    // 为函数返回值赋值
    // load_ptr_t loadInstr = make_load(retAlloc);
    // ret_ptr_t retInstr = make_ret(loadInstr);
    // exitBB->addInstr(loadInstr);
    // exitBB->addInstr(retInstr);

    // 构建函数的主体基本块 main basic block
    block_ptr_t mainBB = make_block("body");
    mainBB->addInstrList(blockInfo.instrList);

    // 将entry, main, exit基本块追加到函数中
    func->addBlock(entryBB);
    func->addBlock(mainBB);
    // func->addBlock(exitBB); // 意义不明，暂时不添加

    return ret_info_t{std::list<user_ptr_t>{func}}.setValue(func);
}

// FuncCall -> ident ( [ArgList] )
ret_info_t RSCVisitor::visitFuncCall(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting func call..." << std::endl;
    assert(
        node->data.symbol == "FuncCall",
        format("Expected node FuncCall, but got $ instead.", node->data.symbol));
    // 获取ident和ArgList
    std::string ident = node->getChildAt(0)->data.symbol;
    if (ident == "print")
    {
        // print函数是内置函数，暂时不生成IR
        warn << "print function is not supported yet" << std::endl;
        return ret_info_t();
    }
    // 查看函数是否已经声明
    func_ptr_t func = context.functionTable.find(ident);
    assert(func != nullptr, "function has not been declared");

    pst_node_ptr_t argListNode = node->getChildAt(1);

    ret_info_t retInfo;
    // 生成call指令并追加到list之后
    call_ptr_t callInstr = make_call(func);
    // 解析ArgList
    if (argListNode->hasChild())
    {
        ret_info_t argListInfo = visitArgList(argListNode->firstChild());
        retInfo.appendInstrList(argListInfo.instrList);
        instr_list_t &list = argListInfo.valueList;
        // 做一步类型转换，将list转换为list<user_ptr_t>
        std::list<user_ptr_t> args(list.begin(), list.end());

        // 检查参数列表是否匹配
        assert(func->matchArgs(args), "function call and declaration mismatch");

        callInstr->addArgs(args);
    }
    retInfo.addInstr(callInstr);
    retInfo.setValue(callInstr);

    return retInfo;
}
```

##### 2.6.5.3 流程控制语句的翻译

For循环：

```C++
// ForStmt -> for ( [VarDecl|Assignment] ; [BoolExpr] ; [Assignment] ) Stmt
ret_info_t RSCVisitor::visitForStmt(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting for stmt..." << std::endl;
    assert(
        node->data.symbol == "Stmt" || node->data.symbol == "Assignment",
        format("Expected node Stmt, but got $ instead.", node->data.symbol));
    context.symbolTable.newScope();
    ret_info_t retInfo;

    block_ptr_t initBB = make_block("for.init");
    block_ptr_t condBB = make_block("for.cond");
    block_ptr_t stmtBB = make_block("for.body");
    block_ptr_t lastBB = make_block("for.last");

    // 解析VarDecl|Assignment
    pst_node_ptr_t varDeclOrAssignNode = node->getChildAt(0);
    if (varDeclOrAssignNode->hasChild())
    {
        pst_node_ptr_t initNode = varDeclOrAssignNode->firstChild();
        if (initNode->data.symbol == "VarDecl")
        {
            // VarDecl
            ret_info_t varDeclInfo = visitVarDecl(initNode);
            initBB->addInstrList(varDeclInfo.instrList);
        }
        else
        {
            // Assignment
            ret_info_t assignInfo = visitAssignment(initNode);
            initBB->addInstrList(assignInfo.instrList);
        }
        retInfo.addInstr(initBB);
    }

    // 解析BoolExpr
    pst_node_ptr_t boolExprNode = node->getChildAt(1);
    if (boolExprNode->hasChild())
    {
        ret_info_t boolExprInfo = visitBoolExpr(boolExprNode->firstChild());
        condBB->addInstrList(boolExprInfo.instrList);
        retInfo.addInstr(condBB);

        // 回填BoolExpr的真出口，指向stmtBB
        boolExprInfo.backpatch(JR_TRUE_EXIT, stmtBB);

        // BoolExpr的假出口，指向for循环的出口（Fall through）
        retInfo.appendJmpList(boolExprInfo.getTargetsOf(JR_FALSE_EXIT), JR_FALL_THROUGH);
    }

    // 解析Stmt
    pst_node_ptr_t stmtNode = node->getChildAt(3);
    ret_info_t stmtInfo = visitStmt(stmtNode);
    stmtBB->addInstrList(stmtInfo.instrList);
    retInfo.addInstr(stmtBB);
    retInfo.unionGoTo(stmtInfo);

    // 解析Assignment
    pst_node_ptr_t assignNode = node->getChildAt(2);
    if (assignNode->hasChild())
    {
        ret_info_t assignInfo = visitAssignment(assignNode->firstChild());
        lastBB->addInstrList(assignInfo.instrList);
    }
    lastBB->addInstr(make_jmp(boolExprNode->hasChild() ? condBB : stmtBB));
    retInfo.addInstr(lastBB);

    // 处理Stmt中的break，指向for循环的出口（Fall through）
    retInfo.appendJmpList(retInfo.getTargetsOf(JR_BREAK_OUT), JR_FALL_THROUGH);

    // 回填Stmt中的continue，指向lastBB
    retInfo.backpatch(JR_CONTINUE, lastBB);

    auto allocas = context.symbolTable.popScope();
    initBB->addInstrListFromFront(allocas);

    return retInfo;
}
```

条件控制：

```C++
// IfStmt -> if ( BoolExpr ) Stmt [else Stmt]
ret_info_t RSCVisitor::visitIfStmt(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting if stmt..." << std::endl;
    assert(
        node->data.symbol == "Stmt",
        format("Expected node Stmt, but got $ instead.", node->data.symbol));
    // 获取BoolExpr返回值
    ret_info_t retInfo;
    ret_info_t boolInfo = visitBoolExpr(node->getChildAt(0));
    retInfo.unionGoTo(boolInfo);
    // 构造条件基本块
    block_ptr_t condBB = make_block("if.cond");
    condBB->addInstrList(boolInfo.instrList);
    retInfo.addInstr(condBB);

    // 构造条件为真时的作用域
    context.symbolTable.newScope();

    // 获取Stmt
    auto stmtInfo = visitStmt(node->getChildAt(1));

    // 将Stmt内容整合为基本块
    block_ptr_t stmtBB = make_block("if.then");
    stmtBB->addInstrList(stmtInfo.instrList);
    retInfo.addInstr(stmtBB);
    retInfo.unionGoTo(stmtInfo);

    // 绑定条件的真出口
    retInfo.backpatch(JR_TRUE_EXIT, stmtBB);

    auto trueAllocas = context.symbolTable.popScope();
    stmtBB->addInstrListFromFront(trueAllocas);

    // 获取else Stmt
    pst_node_ptr_t elseStmtNode = node->getChildAt(2);
    if (elseStmtNode->hasChild())
    {
        // 构造条件为假时的作用域
        context.symbolTable.newScope();

        ret_info_t elseStmtInfo = visitStmt(elseStmtNode->firstChild());

        // 将else Stmt内容整合为基本块
        block_ptr_t elseStmtBB = make_block("if.else");
        elseStmtBB->addInstrList(elseStmtInfo.instrList);
        retInfo.addInstr(elseStmtBB);
        retInfo.unionGoTo(elseStmtInfo);

        // 绑定条件的假出口
        retInfo.backpatch(JR_FALSE_EXIT, elseStmtBB);

        auto falseAllocas = context.symbolTable.popScope();
        elseStmtBB->addInstrListFromFront(falseAllocas);
    }
    else
    {
        // 修改条件的假出口为fall through
        retInfo.shiftReason(JR_FALSE_EXIT, JR_FALL_THROUGH);
    }

    return retInfo;
}
```

##### 2.6.5.4 立即数、局部变量和全局变量

立即数：

```C++
// Factor -> int, real, char, string, true, false
ret_info_t RSCVisitor::visitLiteral(pst_node_ptr_t node)
{
    debug(0) << "RSCVisitor: visiting literal..." << std::endl;
    // 如果node自身是终结符节点，则可能是char, string, true, false
    // 先处理true, false，剩下的就是char, string
    if (_is_term_node(node))
    {
        if (node->data.symbol == "true")
        {
            // true
            auto instr = make_const_bool(true);
            return ret_info_t().setValue(instr);
        }
        else if (node->data.symbol == "false")
        {
            // false
            auto instr = make_const_bool(false);
            return ret_info_t().setValue(instr);
        }
        else if (node->data.symbol[0] == '\'')
        {
            // char
            auto instr = make_const_char(node->data.symbol[1]);
            return ret_info_t().setValue(instr);
        }
        else if (node->data.symbol[0] == '\"')
        {
            // string
            auto instr = make_const_str(node->data.symbol.substr(1, node->data.symbol.size() - 2));
            return ret_info_t().setValue(instr);
        }
        else
        {
            // error
            error << "unknown literal" << std::endl;
            exit(1);
        }
    }
    // 如果node自身是非终结符节点，则可能是int, real
    else
    {
        if (node->data.symbol == "IntLiteral")
        {
            // int
            auto instr = make_const_int(std::stoi(node->firstChild()->data.symbol));
            return VisitorRetInfo().setValue(instr);
        }
        else if (node->data.symbol == "RealLiteral")
        {
            // real
            auto instr = make_const_real(std::stod(node->firstChild()->data.symbol));
            return VisitorRetInfo().setValue(instr);
        }
        else
        {
            // error
            error << "unknown literal" << std::endl;
            exit(1);
        }
    }
}
```

变量的声明和赋值：

```C++
// VarDef -> ident : Type [ InitVal ]
ret_info_t RSCVisitor::visitVarDef(pst_node_ptr_t node, bool global)
{
    debug(0) << "RSCVisitor: visiting var def..." << std::endl;
    assert(
        node->data.symbol == "VarDef",
        format("Expected node VarDef, but got $ instead.", node->data.symbol));
    ret_info_t retInfo;
    // 获取ident和Type
    // 暂时不考虑数组，因此剩余子节点暂时不处理
    std::string identStr = node->getChildAt(0)->data.symbol;
    std::string typeStr = node->getChildAt(1)->firstChild()->data.symbol;

    type_ptr_t type = make_prime_type(PrimitiveType::str2type(typeStr));
    user_ptr_t value = nullptr;

    pst_node_ptr_t initValNode = node->getChildAt(3);
    user_ptr_t initVal = nullptr;
    if (initValNode->hasChild())
    {
        ret_info_t initValInfo = visitInitVal(initValNode->firstChild());
        initVal = initValInfo.getValue();
        retInfo.appendInstrList(initValInfo.instrList);
    }

    if (global)
    {
        assert(
            initVal != nullptr,
            format("global variable $ must be initialized", identStr));
        const_val_ptr_t init = cast_const(initVal);
        value = context.symbolTable.registerGlobal(identStr, type, init);
    }
    else
    {
        value = context.symbolTable.registerAlloca(identStr, type);
        if (initVal != nullptr)
        {
            store_ptr_t storeInstr = make_store(initVal, cast_alloca(value));
            retInfo.addInstr(storeInstr);
        }
    }

    retInfo.setValue(value);

    return retInfo;
}
```

#### 2.6.6 未完待续

由于时间原因，暂时只做到这儿，老师如果有任何问题可以找我**当面质询**。

### 2.7 面向NASM的目标代码生成

#### 2.7.1 未完待续

由于时间原因，暂时只做到这儿，老师如果有任何问题可以找我**当面质询**。

### 2.8 自主编写的辅助开发工具集

为了方便开发过程，我编写了许多好用的小工具。由于时间原因，难以展开讲解，下面简单贴一点代码，若感兴趣，可以进一步交流。

#### 2.8.1 格式化日志输出工具设计与实现

```C++
#define _red(x) "\033[31m" << x << "\033[0m"
#define _blue(x) "\033[34m" << x << "\033[0m"
#define _green(x) "\033[32m" << x << "\033[0m"
#define _yellow(x) "\033[33m" << x << "\033[0m"

#define info std::cout << _green("[info] ")
#define warn std::cout << _yellow("[warn] ")
#define error std::cout << _red("[error] ")
#define fetal std::cout << _red("[fetal] ")

#define DEBUG_LEVEL -1

#define debug(level)          \
	if (level <= DEBUG_LEVEL) \
	std::cout << _blue("   [" #level "] ")

#define debug_u(level)        \
	if (level <= DEBUG_LEVEL) \
	std::cout

#define assert(x, msg)                                    \
	if (!(x))                                             \
	{                                                     \
		fetal << "Assertion \"" << #x << "\" FAILED at "; \
		std::cout << "\033[4m";                           \
		std::cout << __FILE__ << ":" << __LINE__;         \
		std::cout << "\033[0m" << std::endl;              \
		print_ln(msg);                                    \
		throw std::runtime_error("Assertion Failed");     \
		exit(1);                                          \
	}
```

#### 2.8.2 自动表格排版工具设计与实现

```C++
/**
 * @file utils/table.h
 * @author Zhenjie Wei (2024108@bjtu.edu.cn)
 * @brief My Custom Table Render
 * @date 2023-04-22
 *
 * @copyright Copyright (c) 2023
 *
 */

/**
 * 本文件实现了一个自定义的表格渲染器
 * 该渲染器可以将一系列单元格渲染为表格，并且支持自定义表格的样式
 * 渲染器支持的样式包括：内容对齐、字体样式、颜色样式、边框样式
 * 渲染器提供了一系列的接口和操作符重载，用于快速设置单元格的样式
 */

#pragma once

#include "log.h"

#include <map>
#include <vector>
#include <stack>

// TAB在渲染器中控制同一行中的单元格内容合并
#define TB_TAB "\t"

// 合并后的单元格的内容的对齐方式由TAB后的字符决定
#define LF_TAB "\tl"
#define MD_TAB "\tm"
#define RT_TAB "\tr"

// GAP在渲染器中代表一个空的单元格，即跳过该单元格的渲染
#define TB_GAP ""

namespace table
{
    using sign = unsigned char;
    using l_sign = unsigned short int;

    // 用于设置单元格的内容对齐方式
    enum align_t : sign
    {
        AL_DFT,
        AL_LFT,
        AL_CTR,
        AL_RGT,
    };

    // 用于设置单元格的字体样式、颜色样式
    // 由于颜色样式和字体样式是互斥的，因此可以使用位运算来组合样式
    // 比如：FORE_RED | BACK_GRE | FONT_BOL代表绿色背景下的红色粗体字
    enum style_t : l_sign
    {
        FONT_NON = 0b0000000000000000,
        FORE_RED = 0b0000000000000001,
        FORE_GRE = 0b0000000000000010,
        FORE_YEL = 0b0000000000000011,
        FORE_BLU = 0b0000000000000100,
        FORE_PUR = 0b0000000000000101,
        FORE_CYA = 0b0000000000000110,
        FORE_WHI = 0b0000000000000111,
        BACK_RED = 0b0000000000010000,
        BACK_GRE = 0b0000000000100000,
        BACK_YEL = 0b0000000000110000,
        BACK_BLU = 0b0000000001000000,
        BACK_PUR = 0b0000000001010000,
        BACK_CYA = 0b0000000001100000,
        BACK_WHI = 0b0000000001110000,
        FONT_BOL = 0b0000000100000000,
        FONT_ITA = 0b0000001000000000,
        FONT_UND = 0b0000010000000000,
    };

    // 用于设置单元格的边框样式
    // 其中部分边框样式是互斥的，因此可以使用位运算来组合样式
    // 比如：BDR_RUD | BDR_VRT代表含有垂线和外部边框的样式
    enum border_t : sign
    {
        BDR_NON = 0b000000, // No Border
        BDR_LFT = 0b000001, // Left Border
        BDR_TOP = 0b000010, // Top Border
        BDR_RGT = 0b000100, // Right Border
        BDR_BTM = 0b001000, // Bottom Border
        BDR_VRT = 0b010000, // Vertical Border
        BDR_HRT = 0b100000, // Horizontal Border
        BDR_ALL = 0b111111, // All Border
        BDR_RUD = 0b001111, // Rounded Border
    };

    /**
     * @brief 单元格内容，可以由string内容隐式构造
     * 
     */
    class Cell
    {
    public:
        l_sign style;
        align_t align;
        std::string field;
        // 各类构造函数，用于快速设置单元格的内容、样式和对齐方式
        Cell() : field("\x07"), style(FONT_NON), align(AL_DFT) {}
        Cell(const char *s) : field(s), style(FONT_NON), align(AL_DFT) {}
        Cell(l_sign sty) : field("\x07"), style(sty), align(AL_DFT) {}
        Cell(align_t ali) : field("\x07"), style(FONT_NON), align(ali) {}
        Cell(std::string s) : field(s), style(FONT_NON), align(AL_DFT) {}
        Cell(std::string s, l_sign sty, align_t ali) : field(s), style(sty), align(ali) {}

        // 重载的运算符，可以使用&运算符快速设置单元格的内容、样式和对齐方式
        Cell &operator&(const char *s)
        {
            field = s;
            return *this;
        }
        Cell &operator&(const l_sign sty)
        {
            style = sty;
            return *this;
        }
        Cell &operator&(const align_t ali)
        {
            align = ali;
            return *this;
        }
        Cell &operator&(const std::string &s)
        {
            field = s;
            return *this;
        }
    };

    /**
     * @brief 表格渲染器核心类
     * 
     */
    class TableRender
    {
    public:
        TableRender();
        TableRender &reset();
        TableRender &moveTo(int r, int c);
        TableRender &jumpTo(int r, int c);
        TableRender &JumpBack(int n = 1);
        TableRender &carriRet();
        TableRender &lineFeed();
        TableRender &moveNext();
        TableRender &setLine(const int i = 0);
        TableRender &enableLineSetting(bool b = true);
        TableRender &useHorizDirection(bool b = true);
        TableRender &operator=(const l_sign style);
        TableRender &operator=(const align_t align);
        TableRender &operator=(const std::string &field);
        TableRender &operator|(const Cell &cell);
        std::string geneView(sign style = BDR_RUD | BDR_VRT);

    private:
        int rowCur, colCur;
        size_t rowMax, colMax;
        size_t tabWidths;
        align_t tabAlign;
        bool lineSetting;
        bool horizDirected;
        std::vector<size_t> widths;
        std::vector<bool> hLines;
        std::vector<bool> vLines;
        std::vector<std::vector<Cell>> table;
        std::stack<std::pair<int, int>> posStack;

        void resize();
        void resetTabLayout();
        std::pair<size_t, align_t> calcTabLayout(const Cell &cell, size_t i, bool V);
        std::string geneField(const std::string &field, size_t width, size_t c, align_t align, l_sign style) const;
        std::string geneHorizLine(int r, bool L, bool R, bool V) const;
    };
}

// 用于全局的表格渲染器，可以直接使用宏定义来快速设置单元格的内容、样式和对齐方式
// 该方式可以使得代码更加简洁、易读，但不是线程安全的
extern table::TableRender _tableRender;

// 设置表格的头部，即设置表格的第一行，调用该宏后，表格渲染器会先清空表格，然后跳转到第一行
#define tb_head _tableRender.reset().lineFeed().setLine()
// 接着上面继续操作，可以使用tb_cont来继续设置表格的内容
#define tb_cont _tableRender

// 设置表格的列，调用该宏后，表格渲染器会跳转到第一列，并开启整列设置
#define set_col _tableRender.useHorizDirection().carriRet().enableLineSetting()
// 设置表格的行，调用该宏后，表格渲染器会跳转到下一行，并开启整行设置
#define set_row _tableRender.useHorizDirection(false).carriRet().enableLineSetting()

// 新建表格的列，调用该宏后，表格渲染器会跳转到下一列，并关闭整列设置
#define new_col _tableRender.useHorizDirection(false).lineFeed().carriRet().enableLineSetting(false)
// 新建表格的行，调用该宏后，表格渲染器会跳转到下一行，并关闭整行设置
#define new_row _tableRender.useHorizDirection().lineFeed().carriRet().enableLineSetting(false)

// 相对偏移到指定的行和列
#define tb_move(r, c) _tableRender.moveTo(r, c)
// 绝对跳转到指定的行和列
#define tb_jump(r, c) _tableRender.jumpTo(r, c)
// 返回到上一个跳转点
#define tb_back(n) _tableRender.JumpBack(n)

// 新建一条分割线，该线可以是水平线，也可以是垂直线，可以设置偏移量
#define tb_line(x) _tableRender.setLine(x)
// 返回表格的渲染结果，可以设置边框样式
#define tb_view(s) _tableRender.geneView(s)
```



#### 2.8.3 输入流浏览工具设计与实现

```C++
/**
 * @file utils/viewer.h
 * @author Zhenjie Wei (2024108@bjtu.edu.cn)
 * @brief Lightweight String Viewer
 * @date 2023-04-22
 *
 * @copyright Copyright (c) 2023
 *
 */

#pragma once

#include "utils/log.h"

#include <string>
#include <vector>
#include <iomanip>
#include <fstream>
#include <iostream>

/**
 * @brief lightweight string viewer
 */
class Viewer
{
protected:
	std::string str;
	size_t pos = 0;

public:
	static Viewer fromFile(std::string filename)
	{
		std::ifstream ifs(filename);
		assert(
			ifs.is_open(),
			format("Cannot open file: $.", filename));
		std::string str((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
		return Viewer(str);
	}
	Viewer() = default;
	Viewer(const std::string &str) : str(str) {}
	Viewer(const Viewer &v)
	{
		str = v.str;
		pos = v.pos;
	}
	void operator=(Viewer v)
	{
		str = v.str;
		pos = v.pos;
	}
	bool operator>(Viewer &v) const
	{
		return pos > v.pos;
	}
	bool operator>=(Viewer &v) const
	{
		return pos >= v.pos;
	}
	// 获取第i个字符
	char operator[](size_t i) const
	{
		if (i >= str.size())
		{
			return '\0';
		}
		return str[i];
	}
	// 获取字符串大小
	size_t size() const
	{
		return str.size();
	}
	// 获取当前字符
	char peek(size_t i = 0) const
	{
		return (*this)[pos + i];
	}
	// 获取当前字符并移动指针
	char step()
	{
		return (*this)[pos++];
	}
	// 移动指针并获取当前字符
	char next()
	{
		return (*this)[++pos];
	}
	// 判断是否到达末尾
	bool ends() const
	{
		return pos >= str.size();
	}
	// 跳过i个字符（可正可负）
	void skip(int i = 1)
	{
		pos += i;
	}
	// 跳转到指定位置
	void jump(size_t i)
	{
		pos = i;
	}
	// 获取当前位置
	size_t getPos() const
	{
		return pos;
	}
	// 获取字符串
	std::string getStr() const
	{
		return str;
	}
};

```

```C++
/**
 * @file utils/context_viewer.h
 * @author Zhenjie Wei (2024108@bjtu.edu.cn)
 * @brief Lightweight Context Viewer
 * @date 2023-06-03
 *
 * @copyright Copyright (c) 2023
 *
 */

#pragma once

#include "viewer.h"
#include "utils/log.h"

using code_loc_t = std::pair<size_t, size_t>;

class ContextViewer : public Viewer
{
	std::vector<size_t> lineNoVec;
	void initialize()
	{
		size_t pos = str.find('\n');
		while (pos != std::string::npos)
		{
			lineNoVec.push_back(pos);
			pos = str.find('\n', pos + 1);
		}
		lineNoVec.push_back(str.size());
	}

public:
	void operator=(Viewer &v)
	{
		Viewer::operator=(v);
	}

	ContextViewer(std::string str) : Viewer(str)
	{
		initialize();
	}

	ContextViewer(const Viewer &v) : Viewer(v)
	{
		initialize();
	}

	std::pair<size_t, size_t> getCurLineCol() const
	{
		size_t ln = getLineNo();
		size_t col = getPos() - (ln > 1 ? lineNoVec[ln - 2] + 1 : 0);
		return std::make_pair(ln, col);
	}

	std::string getLine(size_t lineNo = -1) const
	{
		if (lineNo == -1)
			lineNo = getLineNo();
		size_t start = lineNo > 1 ? lineNoVec[lineNo - 2] + 1 : 0;
		size_t end = lineNoVec[lineNo - 1];
		return str.substr(start, end - start);
	}

	size_t getLineNo() const
	{
		size_t lineNo = 1;
		for (auto i : lineNoVec)
		{
			if (pos > i)
				lineNo++;
			else
				break;
		}
		return lineNo;
	}

	code_loc_t getLnAndCol() const
	{
		size_t lineNo = getLineNo();
		size_t start = lineNo > 1 ? lineNoVec[lineNo - 2] : 0;
		return std::make_pair(lineNo, pos - start);
	}

	void printContext() const
	{
		size_t ln, col;
		std::tie(ln, col) = getLnAndCol();
		printContext(ln, col);
	}

	void printContext(const size_t ln, const size_t col) const
	{
		size_t startLine = ln - 1 > 0 ? ln - 1 : 1;
		size_t lineMax = lineNoVec.size();
		size_t endLine = ln + 1 < lineMax ? ln + 1 : lineMax;
		for (size_t i = startLine; i <= endLine; i++)
		{
			std::cout << std::setw(3) << i << ": ";
			if (i == ln)
				std::cout << ">>| ";
			else
				std::cout << "  | ";
			std::cout << getLine(i) << std::endl;
			if (i == ln)
				std::cout << std::setw(9 + col) << "^" << std::endl;
		}
	}

	void skipToNextLine()
	{
		size_t lineNo = getLineNo();
		skip(lineNoVec[lineNo - 1] - getPos() + 1);
	}
};
```

```C++
/**
 * @file utils/token_viewer.h
 * @author Zhenjie Wei (2024108@bjtu.edu.cn)
 * @brief Lightweight Token Viewer
 * @date 2023-04-27
 *
 * @copyright Copyright (c) 2023
 *
 */

#pragma once

#include "common/token.h"
#include "utils/log.h"

#include <vector>

class TokenViewer
{
    std::vector<token> &tokens;
    size_t index;

public:
    TokenViewer(std::vector<token> &tokens) : tokens(tokens), index(0) {}
    void operator=(TokenViewer &v)
    {
        tokens = v.tokens;
        index = v.index;
    }
    token &operator[](size_t i) const
    {
        assert(i >= 0 && i < tokens.size());
        return tokens[i];
    }
    size_t pos() const
    {
        return index;
    }
    size_t size() const
    {
        return tokens.size();
    }
    bool ends() const
    {
        return index >= tokens.size();
    }
    token &current() const
    {
        return (*this)[index];
    }
    void advance()
    {
        index++;
    }
    std::vector<token> rest() const
    {
        std::vector<token> ret;
        for (size_t i = index; i < tokens.size(); i++)
            ret.push_back(tokens[i]);
        return ret;
    }
    std::vector<std::string> restTypes() const
    {
        std::vector<std::string> ret;
        for (size_t i = index; i < tokens.size(); i++)
            ret.push_back(*(tokens[i].type));
        return ret;
    }
};

inline std::string descTokVecFrom(const std::vector<token> &v, int i, int limit = 10)
{
    std::stringstream ss;
    for (int j = i; j < v.size() && j < i + limit; j++)
    {
        ss << v[j].value;
        if (j != v.size() - 1)
            ss << " ";
    }
    return ss.str();
}
```

```C++
/**
 * @file utils/word_viewer.h
 * @author Zhenjie Wei (2024108@bjtu.edu.cn)
 * @brief Lightweight Word Viewer
 * @date 2023-06-03
 *
 * @copyright Copyright (c) 2023
 *
 */

#pragma once

#include "viewer.h"
#include "utils/log.h"

using word_loc_t = std::pair<size_t, size_t>;
static constexpr inline const word_loc_t word_npos = std::make_pair(-1, -1);
static constexpr inline const word_loc_t word_end = std::make_pair(-1, 0);

class WordViewer : public Viewer
{
    bool isWord(word_loc_t loc) const
    {
        if (loc.first > 0 && !isspace(str[loc.first - 1]))
            return false;
        if (loc.second < str.length() && !isspace(str[loc.second]))
            return false;
        return true;
    }

public:
    void operator=(Viewer &v)
    {
        Viewer::operator=(v);
    }
    WordViewer() = default;
    WordViewer(std::string str) : Viewer(str) {}
    WordViewer(Viewer &v) : Viewer(v) {}

    std::string operator[](word_loc_t loc) const
    {
        assert(loc != word_npos && loc != word_end, "Invalid word location!");
        return str.substr(loc.first, loc.second - loc.first);
    }

    std::vector<word_loc_t> wordsOfRestLine() const
    {
        std::vector<word_loc_t> ret;
        size_t start = current().first;
        size_t end = str.find('\n', pos);
        while (start < end)
        {
            word_loc_t loc = std::make_pair(start, start);
            while (loc.second < end && !isspace(str[loc.second]))
                loc.second++;
            if (loc.second > loc.first)
                ret.push_back(loc);
            start = loc.second;
            while (start < end && isspace(str[start]))
                start++;
        }
        return ret;
    }

    word_loc_t find(const std::string &word, word_loc_t start = word_npos) const
    {
        // 找到并返回第一个是单词且值为word的位置，否则返回word_npos
        size_t _pos;
        _pos = start == word_npos ? str.find(word) : str.find(word, start.second);
        while (_pos != std::string::npos)
        {
            word_loc_t loc = std::make_pair(_pos, _pos + word.length());
            if (isWord(loc))
                return loc;
            _pos = str.find(word, _pos + 1);
        }
        return word_npos;
    }

    word_loc_t current(size_t p = -1) const
    {
        // 返回loc指定的单词的位置
        size_t start = p == -1 ? pos : p;
        if (isspace(str[start]))
        {
            // 如果当前位置是空白，向前找到下一个单词的开头
            while (isspace(str[start]) && start < str.length())
                start++;
            if (start == str.length())
                return word_end;
        }
        else
        {
            // 如果当前位置不是空白，向后找到当前单词的开头
            while (start > 0 && !isspace(str[start - 1]))
                start--;
        }
        // 向后找到当前单词的结尾
        size_t end = start;
        while (end < str.length() && !isspace(str[end]))
            end++;
        return std::make_pair(start, end);
    }

    word_loc_t advance()
    {
        // 如果当前位置不是空白，向前找到当前单词的结尾空白
        while (pos < str.length() && !isspace(str[pos]))
            pos++;
        // 如果当前位置是空白，向前找到下一个单词的开头
        while (isspace(str[pos]) && pos < str.length())
            pos++;
        if (pos == str.length())
            return word_end;
        return current();
    }

    word_loc_t advance(word_loc_t loc) const
    {
        // 如果当前位置不是空白，向前找到当前单词的结尾空白
        while (loc.first < str.length() && !isspace(str[loc.first]))
            loc.first++;
        // 如果当前位置是空白，向前找到下一个单词的开头
        while (isspace(str[loc.first]) && loc.first < str.length())
            loc.first++;
        if (loc.first == str.length())
            return word_end;
        loc.second = loc.first;
        // 向后找到下一个单词的结尾
        while (loc.second < str.length() && !isspace(str[loc.second]))
            loc.second++;
        return loc;
    }

    word_loc_t retreat()
    {
        // 如果当前位置不是空白，向后找到当前单词的前导空白
        while (pos > 0 && !isspace(str[pos]))
            pos--;
        // 如果当前位置是空白，向后找到上一个单词的结尾
        while (isspace(str[pos]) && pos > 0)
            pos--;
        // 如果当前位置不是空白，向后找到当前单词的开头
        while (pos > 0 && !isspace(str[pos - 1]))
            pos--;
        return current();
    }

    word_loc_t retreat(word_loc_t loc) const
    {
        // 如果当前位置不是空白，向后找到当前单词的前导空白
        while (loc.first > 0 && !isspace(str[loc.first]))
            loc.first--;
        // 如果当前位置是空白，向后找到上一个单词的结尾
        while (isspace(str[loc.first]) && loc.first > 0)
            loc.first--;
        // 记录下上一个单词的结尾
        loc.second = loc.first + 1;
        // 如果当前位置不是空白，向后找到当前单词的开头
        while (loc.first > 0 && !isspace(str[loc.first - 1]))
            loc.first--;
        return loc;
    }

    std::string swallow()
    {
        // 删掉当前单词
        word_loc_t loc = current();
        std::string ret = str.substr(loc.first, loc.second - loc.first);
        str.erase(loc.first, loc.second - loc.first);
        return ret;
    }

    std::string swallow(word_loc_t loc)
    {
        // 删掉loc指定的单词
        std::string ret = str.substr(loc.first, loc.second - loc.first);
        str.erase(loc.first, loc.second - loc.first);
        return ret;
    }

    void swallowWords(const std::vector<word_loc_t> &locs)
    {
        // 先排序
        std::vector<word_loc_t> locs_ = locs;
        sort(
            locs_.begin(), locs_.end(),
            [](const word_loc_t &a, const word_loc_t &b) -> bool
            { return a.first < b.first; });
        // 从后向前删掉locs指定的单词
        for (auto rit = locs_.rbegin(); rit != locs_.rend(); rit++)
            str.erase(rit->first, rit->second - rit->first);
    }

    WordViewer &replace(word_loc_t l1, word_loc_t l2, std::string word)
    {
        // 用word替换l1到l2的单词
        str.replace(l1.first, l2.second - l1.first, word);
        // 更新pos
        if (pos > l1.first)
        {
            if (pos > l2.second)
                pos = pos - (l2.second - l1.first) + word.length();
            else
                pos = l1.first + word.length();
        }
        return *this;
    }

    bool terminate() const
    {
        // 判断是否已经到达末尾
        return pos >= str.length();
    }

    WordViewer &jumpToLoc(word_loc_t loc)
    {
        // 跳转到loc
        pos = loc.first;
        return *this;
    }

    WordViewer &jumpHome()
    {
        // 跳转到开头
        pos = 0;
        return *this;
    }
};
```

#### 2.8.4 项目单元测试流程

略

## 3 运行结果

请查看程序输入输出说明。

## 4 相关记录

### 4.1 代码统计

**Summary**

Date : 2023-06-28 05:40:02

Directory d:\CodeBase\C++Prjs\SatoriCompiler

Total : 109 files, 16803 codes, 1834 comments, 2731 blanks, all 21368 lines

Summary / [Details](https://file+.vscode-resource.vscode-cdn.net/d%3A/CodeBase/C%2B%2BPrjs/SatoriCompiler/.VSCodeCounter/2023-06-28_05-40-02/details.md) / [Diff Summary](https://file+.vscode-resource.vscode-cdn.net/d%3A/CodeBase/C%2B%2BPrjs/SatoriCompiler/.VSCodeCounter/2023-06-28_05-40-02/diff.md) / [Diff Details](https://file+.vscode-resource.vscode-cdn.net/d%3A/CodeBase/C%2B%2BPrjs/SatoriCompiler/.VSCodeCounter/2023-06-28_05-40-02/diff-details.md)

**Languages**

| language | files |  code | comment | blank |  total |
| :------- | ----: | ----: | ------: | ----: | -----: |
| C++      |    96 | 9,259 |   1,831 | 1,216 | 12,306 |
| Markdown |    10 | 7,495 |       0 | 1,504 |  8,999 |
| cmake    |     1 |    32 |       3 |    11 |     46 |
| JSON     |     1 |    15 |       0 |     0 |     15 |
| Batch    |     1 |     2 |       0 |     0 |      2 |

### 4.2 提交记录

![image-20230628054205089](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230628054205089.png)

### 4.3 删改记录

![image-20230620235232134](D:\CodeBase\C++Prjs\SatoriCompiler\docs\assets\image-20230620235232134.png)

## 5 代码说明

### 5.1 代码开源

代码已开源在Github：https://github.com/Kogler7/SatoriCompiler

### 5.2 文件结构

时间原因，来不及说明了，若感兴趣可以当面了解。

## 6 后记

徐老师，对不起，截至6月20号，我的编译器仍然没有完成。**我尽力了**。
之前记得您说，实现一个完整的编译器可以成绩给满。可惜我没有完成这个目标，成绩您看着给就可以，这**并不是我的目的**。代码里有注释，文档有之前写报告留下的一部分，但不完全。其实，我在这个项目上投入了极大的精力，甚至牺牲了许多本该用于其他科目的时间，不过我喜欢这样的过程——**专注而沉浸地朝着某一个中长期目标迈进**，我也喜欢在编程中**创造实践，不断发现问题、迎接挑战、亲手解决问题的感觉**，这是我选择这个方向的原因。代码在GitHub上开源，所有提交记录都在上面，您可以**查看代码一步步成长的轨迹，查看我在这上面花的时间，也可以看到小一万行代码背后的隐含的增、删、改又意味着多少心血**。需要提醒的是，代码的提交记录并不是持续十六周每天都有，这并非因为我懈怠，原因无他，只是在动手之前不可避免地**要学习、思考，要做好充分的设计**罢了。GitHub上代码的第一次提交日期是4月21日，这并不代表我那天才开始做，我只是在那天才将之前做的零星的内容整合成一个项目，给其取名为SatoriCompiler（意味顿悟、开悟），将其正式开源。历史总是惊人的相似，我倾向于选择最难的那条路，让自己在期末承受着巨大的压力和风险，也失去了许多赢得高分的机会。**但我未曾后悔，因为这样的生活对我而言才是充实和有意义的**。感谢老师一学期以来的指导，也希望能得到老师的认可和理解，**谢谢老师**！